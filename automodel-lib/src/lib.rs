mod codegen;
mod config;
mod type_extraction;
mod yaml_parser;

use codegen::*;
use config::*;
use type_extraction::*;
use yaml_parser::*;

use anyhow::Result;
use std::path::Path;

/// Main entry point for the automodel library
pub struct AutoModel {
    queries: Vec<QueryDefinition>,
    telemetry: Option<TelemetryConfig>,
}

impl AutoModel {
    /// Calculate hash of a file for caching purposes
    /// Uses a simple deterministic hash based on file size and a sample of content
    fn calculate_file_hash<P: AsRef<Path>>(path: P) -> Result<u64> {
        use std::fs;
        let contents = fs::read(path)?;

        // Simple deterministic hash: combine file size with hash of content
        let size = contents.len() as u64;
        let mut hash = size.wrapping_mul(31);

        // Hash content in chunks to create a deterministic value
        for (i, &byte) in contents.iter().enumerate() {
            hash = hash
                .wrapping_mul(31)
                .wrapping_add(byte as u64)
                .wrapping_add(i as u64);
        }

        Ok(hash)
    }

    /// Check if generated code is up to date by comparing file hash
    fn is_generated_code_up_to_date<P: AsRef<Path>, Q: AsRef<Path>>(
        yaml_path: P,
        generated_file: Q,
    ) -> Result<bool> {
        use std::fs;

        // If generated file doesn't exist, we need to regenerate
        if !generated_file.as_ref().exists() {
            return Ok(false);
        }

        // Calculate current YAML hash
        let current_hash = Self::calculate_file_hash(&yaml_path)?;

        // Read first line of generated file to check for hash comment
        let generated_content = fs::read_to_string(generated_file)?;
        let first_line = generated_content.lines().next().unwrap_or("");

        // Look for hash comment pattern: // AUTOMODEL_HASH: <hash>
        if let Some(hash_comment) = first_line.strip_prefix("// AUTOMODEL_HASH: ") {
            if let Ok(stored_hash) = hash_comment.trim().parse::<u64>() {
                return Ok(stored_hash == current_hash);
            }
        }

        // No valid hash found, need to regenerate
        Ok(false)
    }

    /// Create a new AutoModel instance by loading queries from a YAML file
    pub async fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let config = parse_yaml_file(path).await?;

        Ok(Self {
            queries: config.queries,
            telemetry: config.telemetry,
        })
    }

    /// Generate Rust code for all loaded queries
    pub async fn generate_code(&self, database_url: &str) -> Result<String> {
        self.generate_code_for_module(database_url, None).await
    }

    /// Generate Rust code for queries in a specific module
    /// If module is None, generates code for queries without a module specified
    pub async fn generate_code_for_module(
        &self,
        database_url: &str,
        module: Option<&str>,
    ) -> Result<String> {
        self.generate_code_for_module_with_hash(database_url, module, None)
            .await
    }

    /// Generate Rust code for queries in a specific module with optional hash header
    /// If module is None, generates code for queries without a module specified
    /// If yaml_hash is provided, adds hash comment at the top for caching
    async fn generate_code_for_module_with_hash(
        &self,
        database_url: &str,
        module: Option<&str>,
        yaml_hash: Option<u64>,
    ) -> Result<String> {
        let mut generated_code = String::new();

        // Add hash comment at the top if provided
        if let Some(hash) = yaml_hash {
            generated_code.push_str(&format!("// AUTOMODEL_HASH: {}\n", hash));
            generated_code.push_str(
                "// This file was automatically generated by AutoModel. Do not edit manually.\n\n",
            );
        }

        // Filter queries for this module
        let module_queries: Vec<&QueryDefinition> = self
            .queries
            .iter()
            .filter(|q| q.module.as_deref() == module)
            .collect();

        if module_queries.is_empty() {
            return Ok(generated_code);
        }

        // Collect type information for all queries in this module
        let mut type_infos = Vec::new();
        for query in &module_queries {
            let type_info =
                extract_query_types(database_url, &query.sql, query.types.as_ref()).await?;
            type_infos.push(type_info);
        }

        // Check if any query has output types (needs Row trait for try_get method)
        let needs_row_import = type_infos.iter().any(|ti| !ti.output_types.is_empty());
        if needs_row_import {
            generated_code.push_str("use sqlx::Row;\n\n");
        }

        // Extract and generate all unique enum types for this module
        let mut all_enum_types = std::collections::HashMap::new();
        for type_info in &type_infos {
            let enum_types = extract_enum_types(&type_info.input_types, &type_info.output_types);
            for (enum_name, enum_variants, pg_type_name) in enum_types {
                all_enum_types.insert(enum_name, (enum_variants, pg_type_name));
            }
        }

        // Generate enum definitions once at the top of the module
        for (enum_name, (enum_variants, pg_type_name)) in all_enum_types {
            generated_code.push_str(&generate_enum_definition(
                &enum_variants,
                &enum_name,
                &pg_type_name,
            ));
            generated_code.push('\n');
        }

        // Generate functions without enum definitions (since they're already at the top)
        for (query, type_info) in module_queries.iter().zip(type_infos.iter()) {
            let function_code =
                generate_function_code_without_enums(query, type_info, self.telemetry.as_ref())?;
            generated_code.push_str(&function_code);
            generated_code.push('\n');
        }

        Ok(generated_code)
    }

    /// Get all unique module names from the loaded queries
    pub fn get_modules(&self) -> Vec<String> {
        let mut modules: Vec<String> = self
            .queries
            .iter()
            .filter_map(|q| q.module.clone())
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect();
        modules.sort();
        modules
    }

    /// Get all loaded queries
    pub fn queries(&self) -> &[QueryDefinition] {
        &self.queries
    }

    /// Build script helper for automatically generating code at build time.
    ///
    /// This function should be called from your build.rs script. It will:
    /// - Check if AUTOMODEL_DATABASE_URL environment variable is set
    /// - Calculate hash of YAML file and check if generated code is up to date
    /// - If generated code is up to date, skip database connection entirely
    /// - If not up to date and DATABASE_URL is set, regenerate code
    /// - If not up to date and no DATABASE_URL, fail the build
    /// - Organize functions into modules based on the `module` field in queries
    /// - Generate separate .rs files for each module and a main mod.rs that includes them
    /// - Add hash comments to generated files for future caching
    ///
    /// # Arguments
    ///
    /// * `yaml_file` - Path to the YAML file containing query definitions (relative to build.rs)
    /// * `output_dir` - Path to the directory where module files will be written (relative to build.rs, typically "src/generated")
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// // build.rs
    /// use automodel::AutoModel;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     AutoModel::generate_at_build_time("queries.yaml", "src/generated").await?;
    ///     
    ///     Ok(())
    /// }
    /// ```
    pub async fn generate_at_build_time(
        yaml_file: &str,
        output_dir: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        use std::env;
        use std::fs;
        use std::path::Path;

        let output_path = Path::new(output_dir);

        // Tell cargo to rerun if the input YAML file changes
        println!("cargo:rerun-if-changed={}", yaml_file);

        // Calculate hash of YAML file for caching
        let yaml_hash = Self::calculate_file_hash(yaml_file)?;

        // Check if generated code is up to date
        let mod_file_path = output_path.join("mod.rs");
        let code_up_to_date =
            Self::is_generated_code_up_to_date(yaml_file, &mod_file_path).unwrap_or(false);

        if code_up_to_date {
            println!("cargo:info=Generated code is up to date, skipping database connection");
            return Ok(());
        }

        // Generated code is out of date, need to regenerate
        println!("cargo:info=YAML file changed or generated code missing, regeneration required");

        // Check for database URL (try AUTOMODEL_DATABASE_URL first, then fall back to DATABASE_URL)
        let database_url = env::var("AUTOMODEL_DATABASE_URL")
            .or_else(|_| env::var("DATABASE_URL"))
            .map_err(|_| {
                eprintln!("cargo:error=AUTOMODEL_DATABASE_URL (or DATABASE_URL) environment variable must be set for code generation");
                eprintln!("cargo:error=Set AUTOMODEL_DATABASE_URL to your PostgreSQL connection string");
                std::io::Error::new(std::io::ErrorKind::NotFound, "AUTOMODEL_DATABASE_URL environment variable not set")
            })?;

        println!("cargo:info=Database URL found, generating database functions...");

        // Create AutoModel instance and load queries from YAML file
        let automodel = AutoModel::new(yaml_file).await?;

        // Create output directory if it doesn't exist
        fs::create_dir_all(output_path)?;

        // Get all unique modules
        let modules = automodel.get_modules();
        let mut mod_declarations = Vec::new();

        // Generate code for queries without a module (main mod.rs content)
        // Don't add hash to main module code since we'll add it to mod.rs directly
        let main_module_code = automodel
            .generate_code_for_module(&database_url, None)
            .await?;

        // Generate separate files for each named module
        for module in &modules {
            let module_code = automodel
                .generate_code_for_module_with_hash(&database_url, Some(module), Some(yaml_hash))
                .await?;
            let module_file = output_path.join(format!("{}.rs", module));
            fs::write(&module_file, &module_code)?;
            mod_declarations.push(format!("pub mod {};", module));

            // Tell cargo to rerun if any module file is manually modified
            println!("cargo:rerun-if-changed={}", module_file.display());
        }

        // Create the main mod.rs file
        let mod_file = output_path.join("mod.rs");
        let mut mod_content = String::new();

        // Add hash comment at the top for caching
        mod_content.push_str(&format!("// AUTOMODEL_HASH: {}\n", yaml_hash));
        mod_content.push_str("// This file was automatically generated by AutoModel. Do not edit manually.\n\n");

        // Add module declarations first
        if !mod_declarations.is_empty() {
            for declaration in mod_declarations {
                mod_content.push_str(&declaration);
                mod_content.push('\n');
            }
            mod_content.push('\n');
        }

        // Add the main module code (functions without a specific module)
        // Skip if it's empty or just the hash header
        let trimmed_main_code = main_module_code.trim();
        if !trimmed_main_code.is_empty() && 
           !trimmed_main_code.starts_with("// AUTOMODEL_HASH:") &&
           trimmed_main_code.lines().any(|line| !line.starts_with("//") && !line.trim().is_empty()) {
            mod_content.push_str(&main_module_code);
        }

        fs::write(&mod_file, &mod_content)?;

        // Tell cargo to rerun if the mod.rs file is manually modified
        println!("cargo:rerun-if-changed={}", mod_file.display());

        println!(
            "cargo:info=Successfully generated database functions at {}",
            output_path.display()
        );
        if !modules.is_empty() {
            println!("cargo:info=Generated modules: {}", modules.join(", "));
        }

        Ok(())
    }
}
