use crate::codegen::types_generator::{
    generate_conditional_diff_params, generate_conditional_diff_struct,
    generate_input_params_with_names, generate_multiunzip_input_struct, generate_multiunzip_param,
    generate_result_struct_with_name, generate_return_type, generate_structured_params_signature,
    generate_structured_params_struct,
};
use crate::query_definition::{ExpectedResult, QueryDefinition, TelemetryLevel};
use crate::types_extractor::{
    convert_named_params_to_positional, parse_parameter_names_from_sql, OutputColumn, QueryTypeInfo,
};
use crate::utils::{to_pascal_case, to_snake_case};
use anyhow::Result;

pub fn generate_root_module(modules: &Vec<String>, source_hash: u64) -> String {
    let mut mod_content = String::new();

    // Add hash comment at the top for consistency with build-time generation
    mod_content.push_str(&format!("// AUTOMODEL_HASH: {}\n", source_hash));
    mod_content.push_str(
        "// This file was automatically generated by AutoModel. Do not edit manually.\n\n",
    );

    let mut mod_declarations = Vec::new();
    for module in modules {
        mod_declarations.push(format!("pub mod {};", module));
    }

    // Add module declarations first
    if !mod_declarations.is_empty() {
        for declaration in mod_declarations {
            mod_content.push_str(&declaration);
            mod_content.push('\n');
        }
        mod_content.push('\n');
    }

    // Add generic Error type
    mod_content.push_str(&generate_generic_error_type());

    mod_content
}

/// Generate the generic Error<C> type for mod.rs
pub fn generate_generic_error_type() -> String {
    r#"#[derive(Debug, Clone)]
pub struct ErrorConstraintInfo {
    /// Name of the violated constraint
    pub constraint_name: String,
    pub table_name: String,
    #[allow(unused)]
    pub kind: ErrorConstraintKind,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ErrorConstraintKind {
    UniqueViolation,
    ForeignKeyViolation,
    NotNullViolation,
    CheckViolation,
    Other,
}

impl From<sqlx::error::ErrorKind> for ErrorConstraintKind {
    fn from(kind: sqlx::error::ErrorKind) -> Self {
        match kind {
            sqlx::error::ErrorKind::UniqueViolation => Self::UniqueViolation,
            sqlx::error::ErrorKind::ForeignKeyViolation => Self::ForeignKeyViolation,
            sqlx::error::ErrorKind::NotNullViolation => Self::NotNullViolation,
            sqlx::error::ErrorKind::CheckViolation => Self::CheckViolation,
            _ => Self::Other,
        }
    }
}

/// Generic error type
#[derive(Debug)]
pub enum Error<C: TryFrom<ErrorConstraintInfo>> {
    /// Catches the cases when a mutation query violates a constraint
    /// Type C would be an enum specific to each query.
    /// It would enumerate variants in pascal case for each constraint that can be violated.
    /// The list of constaints is inferred automatically by the automodel based on the table schema
    /// involved in the query.
    /// The Option<C> is None when the constraint name is not recognized (unknown constraint).
    ConstraintViolation(Option<C>, ErrorConstraintInfo),

    /// Row not found error
    RowNotFound,
    
    /// System under stress, timeout
    PoolTimeout,

    InternalError(String, sqlx::Error),
}

impl<C: TryFrom<ErrorConstraintInfo>> From<sqlx::Error> for Error<C> {
    fn from(error: sqlx::Error) -> Self {
        match &error {
            sqlx::Error::RowNotFound => Self::RowNotFound,
            sqlx::Error::ColumnNotFound(col) => {
                Self::InternalError(format!("Column not found: {}", col), error)
            }
            sqlx::Error::Database(db_err) => {
                // Extract constraint name and table from error
                let constraint_name = db_err.constraint().unwrap_or("").to_string();
                let table_name = db_err.table().unwrap_or("").to_string();
                let kind = db_err.kind();

                let violation = ErrorConstraintInfo {
                    constraint_name,
                    table_name,
                    kind: kind.into(),
                };
                Self::ConstraintViolation(violation.clone().try_into().ok(), violation)
            }
            sqlx::Error::Configuration(_) => {
                Self::InternalError("Configuration error".to_string(), error)
            }
            sqlx::Error::InvalidArgument(_) => {
                Self::InternalError("Invalid argument".to_string(), error)
            }
            sqlx::Error::Io(_) => Self::InternalError("IO error".to_string(), error),
            sqlx::Error::Tls(_) => Self::InternalError("TLS error".to_string(), error),
            sqlx::Error::Protocol(_) => Self::InternalError("Protocol error".to_string(), error),
            sqlx::Error::TypeNotFound { type_name } => {
                Self::InternalError(format!("Type not found: {}", type_name), error)
            }
            sqlx::Error::ColumnIndexOutOfBounds { index, len } => Self::InternalError(
                format!("Column index out of bounds: index {}, len {}", index, len),
                error,
            ),
            sqlx::Error::ColumnDecode { index, source } => Self::InternalError(
                format!("Column decode error at index {}: {}", index, source),
                error,
            ),
            sqlx::Error::Encode(_) => Self::InternalError("Encode error".to_string(), error),
            sqlx::Error::Decode(_) => Self::InternalError("Decode error".to_string(), error),
            sqlx::Error::AnyDriverError(_) => {
                Self::InternalError("Driver error".to_string(), error)
            }
            sqlx::Error::PoolTimedOut => Self::PoolTimeout,
            sqlx::Error::PoolClosed => Self::InternalError("Pool closed".to_string(), error),
            sqlx::Error::WorkerCrashed => Self::InternalError("Worker crashed".to_string(), error),
            sqlx::Error::Migrate(_) => Self::InternalError("Migration error".to_string(), error),
            sqlx::Error::InvalidSavePointStatement => Self::InternalError(
                "Invalid save point statement".to_string(),
                error,
            ),
            sqlx::Error::BeginFailed => Self::InternalError("Begin failed".to_string(), error),
            _ => Self::InternalError("Unknown sqlx error".to_string(), error),
        }
    }
}

impl<C> std::fmt::Display for Error<C>
where
    C: std::fmt::Debug + TryFrom<ErrorConstraintInfo>,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::ConstraintViolation(constraint, info) => {
                if let Some(c) = constraint {
                    write!(f, "Constraint violation: {:#?}", c)
                } else {
                    write!(f, "Unknown constraint violation: {} on table {}", info.constraint_name, info.table_name)
                }
            }
            Error::RowNotFound => write!(f, "Row not found"),
            Error::PoolTimeout => write!(f, "Pool timeout"),
            Error::InternalError(msg, err) => {
                write!(f, "Internal error: {}, caused by: {}", msg, err)
            }
        }
    }
}

impl<C> std::error::Error for Error<C>
where
    C: std::fmt::Debug + TryFrom<ErrorConstraintInfo>,
{
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::InternalError(_, err) => Some(err),
            _ => None,
        }
    }
}

/// Generic error type for read-only queries
#[derive(Debug)]
pub enum ErrorReadOnly {
    /// Row not found error
    RowNotFound,

    /// System under stress, timeout
    PoolTimeout,

    InternalError(String, sqlx::Error),
}

impl From<sqlx::Error> for ErrorReadOnly {
    fn from(error: sqlx::Error) -> Self {
        Error::<ErrorConstraintInfo>::from(error).into()
    }
}

impl Into<Error<ErrorConstraintInfo>> for ErrorReadOnly {
    fn into(self) -> Error<ErrorConstraintInfo> {
        match self {
            ErrorReadOnly::RowNotFound => Error::RowNotFound,
            ErrorReadOnly::PoolTimeout => Error::PoolTimeout,
            ErrorReadOnly::InternalError(msg, err) => Error::InternalError(msg, err),
        }
    }
}

impl From<Error<ErrorConstraintInfo>> for ErrorReadOnly {
    fn from(error: Error<ErrorConstraintInfo>) -> Self {
        match error {
            Error::RowNotFound => Self::RowNotFound,
            Error::PoolTimeout => Self::PoolTimeout,
            Error::InternalError(msg, err) => Self::InternalError(msg, err),
            Error::ConstraintViolation(c, info) => Self::InternalError(
                "Constraint violation in read-only query".to_string(),
                sqlx::Error::Protocol(format!(
                    "Constraint violation in read-only query: constraint={}, table={}, parsed={:?}",
                    info.constraint_name, info.table_name, c
                )),
            ),
        }
    }
}

impl std::fmt::Display for ErrorReadOnly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ErrorReadOnly::RowNotFound => write!(f, "Row not found"),
            ErrorReadOnly::PoolTimeout => write!(f, "Pool timeout"),
            ErrorReadOnly::InternalError(msg, err) => {
                write!(f, "Internal error: {}, caused by: {}", msg, err)
            }
        }
    }
}

impl std::error::Error for ErrorReadOnly {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InternalError(_, err) => Some(err),
            _ => None,
        }
    }
}

"#
    .to_string()
}

/// Generate per-query constraint enum with TryFrom<ErrorConstraintInfo> implementation
pub fn generate_query_constraint_enum(
    enum_name: &str,
    constraints: &[crate::types_extractor::ConstraintInfo],
) -> String {
    use std::collections::HashSet;

    let mut code = String::new();

    // Deduplicate constraints by name
    let mut seen_constraints: HashSet<String> = HashSet::new();
    let mut unique_constraints = Vec::new();
    for constraint in constraints {
        if !seen_constraints.contains(&constraint.name) {
            seen_constraints.insert(constraint.name.clone());
            unique_constraints.push(constraint);
        }
    }

    code.push_str(&format!(
        "/// Constraint violations specific to this query\n"
    ));
    code.push_str("#[derive(Debug)]\n");
    code.push_str(&format!("pub enum {} {{\n", enum_name));

    // Generate a variant for each unique constraint
    for constraint in &unique_constraints {
        let variant_name = to_pascal_case(&constraint.name);
        code.push_str(&format!(
            "    /// Constraint: {} on table {}\n",
            constraint.name, constraint.table_name
        ));
        code.push_str(&format!("    {},\n", variant_name));
    }

    code.push_str("}\n\n");

    // Generate TryFrom<ErrorConstraintInfo> implementation
    code.push_str(&format!(
        "impl TryFrom<super::ErrorConstraintInfo> for {} {{\n",
        enum_name
    ));
    code.push_str("    type Error = ();\n\n");
    code.push_str(
        "    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {\n",
    );
    code.push_str("        match info.constraint_name.as_str() {\n");

    for constraint in &unique_constraints {
        let variant_name = to_pascal_case(&constraint.name);
        code.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            constraint.name, variant_name
        ));
    }

    code.push_str("            _ => Err(()),\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}

/// Remove statistics from EXPLAIN plan lines to make output stable
/// Removes patterns like: (cost=X..Y rows=Z width=W)
fn remove_plan_statistics(line: &str) -> String {
    use regex::Regex;
    use std::sync::OnceLock;

    static RE: OnceLock<Regex> = OnceLock::new();
    let re = RE.get_or_init(|| {
        // Match patterns like (cost=10000000000.00..10000000003.74 rows=59 width=64)
        // The pattern handles:
        // - Optional cost=X..Y
        // - Optional rows=Z
        // - Optional width=W
        // All enclosed in parentheses with spaces
        Regex::new(r"\s*\((?:cost=[\d.]+\.\.[\d.]+\s*)?(?:rows=\d+\s*)?(?:width=\d+\s*)?\)")
            .unwrap()
    });

    re.replace_all(line, "").trim_end().to_string()
}

/// Generate tracing::instrument attribute for a function
fn generate_tracing_attribute(query: &QueryDefinition, param_names: &[String]) -> String {
    use std::collections::HashSet;

    let telemetry_level = query.telemetry.level;
    if telemetry_level == TelemetryLevel::None {
        return String::new();
    }

    let mut attributes = Vec::new();

    // No need for explicit span name - tracing::instrument will use the function name automatically

    // Add instrumentation level
    let level = match telemetry_level {
        TelemetryLevel::Info => "info",
        TelemetryLevel::Debug => "debug",
        TelemetryLevel::Trace => "trace",
        TelemetryLevel::None => unreachable!(),
    };
    attributes.push(format!("level = \"{}\"", level));

    // Determine parameter skipping strategy
    let mut skip_params = HashSet::new();
    skip_params.insert("executor".to_string());

    // Parameter inclusion logic (independent of telemetry level)
    if let Some(include_params) = &query.telemetry.include_params {
        if include_params.is_empty() {
            // Empty include_params list means skip all parameters
            skip_params.extend(param_names.iter().cloned());
        } else {
            let included: Vec<String> = include_params
                .iter()
                .filter(|param| param_names.contains(param))
                .cloned()
                .collect();

            if !included.is_empty() {
                // Skip parameters not in the include list
                for param in param_names {
                    if !included.contains(param) {
                        skip_params.insert(param.clone());
                    }
                }
            } else {
                // No valid included parameters, skip all
                skip_params.extend(param_names.iter().cloned());
            }
        }
    } else {
        // No include_params specified, skip all parameters
        skip_params.extend(param_names.iter().cloned());
    }

    // Check if we should use skip_all (all params including query params are skipped)
    let total_params = param_names.len() + 1; // +1 for executor
    let should_use_skip_all = param_names.len() > 0 && skip_params.len() == total_params;

    // Generate skip attribute
    if should_use_skip_all {
        attributes.push("skip_all".to_string());
    } else if skip_params.len() > 1 {
        // More than just executor
        let mut skip_vec: Vec<_> = skip_params.into_iter().collect();
        skip_vec.sort(); // Sort for consistent output
        attributes.push(format!("skip({})", skip_vec.join(", ")));
    } else {
        attributes.push("skip_all".to_string());
    }

    // Determine whether to include SQL based on configuration (default false)
    let should_include_sql = query.telemetry.include_sql;
    if should_include_sql {
        let escaped_sql = query
            .sql
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        attributes.push(format!("fields(sql = \"{}\")", escaped_sql));
    }

    format!("#[tracing::instrument({})]\n", attributes.join(", "))
}

/// Generate an indented raw string literal with proper formatting
fn generate_indented_raw_string_literal(sql: &str) -> String {
    // Find a delimiter that doesn't appear in the SQL
    let mut delimiter_count = 0;
    let delimiter = loop {
        let delimiter = "#".repeat(delimiter_count);
        let pattern = format!("\"{}\"", delimiter);
        if !sql.contains(&pattern) {
            break delimiter;
        }
        delimiter_count += 1;
    };

    // Add proper indentation to each line of SQL
    let indented_sql = sql
        .lines()
        .enumerate()
        .map(|(i, line)| {
            if i == 0 {
                line.to_string() // First line doesn't need extra indentation
            } else {
                format!("        {}", line) // Subsequent lines get 8 spaces of indentation
            }
        })
        .collect::<Vec<_>>()
        .join("\n");

    format!(
        "        r{delimiter}\"{indented_sql}\"{delimiter}",
        delimiter = delimiter,
        indented_sql = indented_sql
    )
}

/// Generate Rust function code for a SQL query without enum definitions
/// (assumes enums are already defined elsewhere in the module)
pub fn generate_function_code_without_enums(
    query: &QueryDefinition,
    type_info: &QueryTypeInfo,
    emitted_struct_names: &mut std::collections::HashSet<String>,
    constraints: &[crate::types_extractor::ConstraintInfo],
    performance_analysis: &Option<crate::query_definition_rt::PerformanceAnalysis>,
) -> Result<String> {
    let mut code = String::new();

    // Generate per-query constraint enum if there are constraints
    let constraint_enum_name = if !constraints.is_empty() {
        // Determine the enum name from error_type config or use default
        let enum_name = if let Some(ref custom_name) = query.error_type {
            custom_name.to_string()
        } else {
            format!("{}Constraints", to_pascal_case(&query.name))
        };

        // Only generate the enum if it hasn't been emitted yet
        if !emitted_struct_names.contains(&enum_name) {
            code.push_str(&generate_query_constraint_enum(&enum_name, constraints));
            code.push('\n');
            emitted_struct_names.insert(enum_name.clone());
        }

        Some(enum_name)
    } else {
        None
    };

    // Extract clean parameter names directly from the SQL for function signature
    let original_param_names = parse_parameter_names_from_sql(&query.sql);
    let clean_param_names: Vec<String> = original_param_names
        .iter()
        .map(|name| {
            if name.ends_with('?') {
                name.trim_end_matches('?').to_string()
            } else {
                name.clone()
            }
        })
        .collect();

    let use_multiunzip = query.multiunzip;

    // Determine if conditions_type is enabled and get the struct name override
    let (use_conditional_diff, diff_struct_name_override) = match &query.conditions_type {
        crate::query_definition::ConditionsType::Enabled(true) => (true, None),
        crate::query_definition::ConditionsType::Named(name) => (true, Some(name.as_str())),
        _ => (false, None),
    };

    // Determine if parameters_type is enabled and get the struct name
    let (use_structured_params, struct_name_override) = match &query.parameters_type {
        crate::query_definition::ParametersType::Enabled(true) if !use_conditional_diff => {
            (true, None)
        }
        crate::query_definition::ParametersType::Named(name) if !use_conditional_diff => {
            (true, Some(name.as_str()))
        }
        _ => (false, None),
    };

    // Generate input struct for multiunzip if needed
    if use_multiunzip {
        let struct_name = format!("{}Record", to_pascal_case(&query.name));
        if !emitted_struct_names.contains(&struct_name) {
            if let Some(input_struct) = generate_multiunzip_input_struct(
                &query.name,
                &clean_param_names,
                &type_info.input_types,
            ) {
                code.push_str(&input_struct);
                code.push('\n');
                emitted_struct_names.insert(struct_name);
            }
        }
    }

    // Generate diff struct for conditions_type if needed
    if use_conditional_diff && type_info.parsed_sql.is_some() {
        let struct_name = if let Some(override_name) = diff_struct_name_override {
            override_name.to_string()
        } else {
            format!("{}Params", to_pascal_case(&query.name))
        };

        if !emitted_struct_names.contains(&struct_name) {
            if let Some(diff_struct) = generate_conditional_diff_struct(
                &struct_name,
                &original_param_names,
                &type_info.input_types,
            ) {
                code.push_str(&diff_struct);
                code.push('\n');
                emitted_struct_names.insert(struct_name);
            }
        }
    }

    // Generate struct for parameters_type if needed (but not for conditions_type)
    if use_structured_params {
        let struct_name = if let Some(override_name) = struct_name_override {
            override_name.to_string()
        } else {
            format!("{}Params", to_pascal_case(&query.name))
        };

        if !emitted_struct_names.contains(&struct_name) {
            if let Some(params_struct) = generate_structured_params_struct(
                struct_name_override.unwrap_or(&query.name),
                &clean_param_names,
                &type_info.input_types,
            ) {
                code.push_str(&params_struct);
                code.push('\n');
                emitted_struct_names.insert(struct_name);
            }
        }
    }

    // Generate result struct if needed (but no enums)
    if type_info.output_types.len() > 1 {
        let result_struct_name = if let Some(ref custom_name) = query.return_type {
            custom_name.to_string()
        } else {
            format!("{}Item", to_pascal_case(&query.name))
        };

        if !emitted_struct_names.contains(&result_struct_name) {
            if let Some(struct_def) =
                generate_result_struct_with_name(&result_struct_name, &type_info.output_types)
            {
                code.push_str(&struct_def);
                code.push('\n');
                emitted_struct_names.insert(result_struct_name);
            }
        }
    }

    // Generate function documentation
    if let Some(description) = &query.description {
        code.push_str(&format!("/// {}\n", description));
    }

    // Add query plan as documentation comments if available
    if let Some(perf_analysis) = performance_analysis {
        if let Some(plan) = &perf_analysis.query_plan {
            code.push_str("///\n");
            code.push_str("/// Query Plan:\n");
            for line in plan.lines() {
                // Remove cost estimates, row counts, and width from the plan to avoid instability
                // These values change between runs and make the generated code unstable
                let cleaned_line = remove_plan_statistics(line);
                code.push_str(&format!("/// {}\n", cleaned_line));
            }
        }
    }

    let tracing_attribute = generate_tracing_attribute(query, &clean_param_names);
    code.push_str(&tracing_attribute);

    let input_params = if use_multiunzip {
        // For multiunzip, generate a single Vec<StructName> parameter
        generate_multiunzip_param(&query.name, "items")
    } else if use_conditional_diff && type_info.parsed_sql.is_some() {
        // For conditions_type, generate old and new struct parameters
        generate_conditional_diff_params(
            &query.name,
            &original_param_names,
            &type_info.input_types,
            diff_struct_name_override.as_deref(),
        )
    } else if use_structured_params {
        // For parameters_type, generate a single struct parameter
        generate_structured_params_signature(&query.name, struct_name_override.as_deref())
    } else {
        generate_input_params_with_names(&type_info.input_types, &clean_param_names)
    };

    let base_return_type = if type_info.output_types.len() > 1 {
        // Multi-column result - use struct name
        if let Some(ref custom_name) = query.return_type {
            custom_name.to_string()
        } else {
            format!("{}Item", to_pascal_case(&query.name))
        }
    } else {
        // Single column result - use direct type
        generate_return_type(type_info.output_types.first())
    };

    // Generate function signature
    let params_str = if input_params.is_empty() {
        "executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>".to_string()
    } else {
        format!(
            "executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, {}",
            input_params
        )
    };

    let return_type = if type_info.output_types.is_empty() {
        let error_type = if let Some(ref enum_name) = constraint_enum_name {
            format!("super::Error<{}>", enum_name)
        } else {
            "super::ErrorReadOnly".to_string()
        };
        format!("Result<(), {}>", error_type)
    } else {
        match query.expect {
            ExpectedResult::ExactlyOne => {
                let error_type = if let Some(ref enum_name) = constraint_enum_name {
                    format!("super::Error<{}>", enum_name)
                } else {
                    "super::ErrorReadOnly".to_string()
                };
                format!("Result<{}, {}>", base_return_type, error_type)
            }
            ExpectedResult::PossibleOne => {
                let error_type = if let Some(ref enum_name) = constraint_enum_name {
                    format!("super::Error<{}>", enum_name)
                } else {
                    "super::ErrorReadOnly".to_string()
                };
                format!("Result<Option<{}>, {}>", base_return_type, error_type)
            }
            ExpectedResult::AtLeastOne | ExpectedResult::Multiple => {
                let error_type = if let Some(ref enum_name) = constraint_enum_name {
                    format!("super::Error<{}>", enum_name)
                } else {
                    "super::ErrorReadOnly".to_string()
                };
                format!("Result<Vec<{}>, {}>", base_return_type, error_type)
            }
        }
    };

    code.push_str(&format!(
        "pub async fn {}({}) -> {} {{\n",
        query.name, params_str, return_type
    ));

    // Generate function body
    let function_body = generate_function_body(query, type_info, &base_return_type)?;
    code.push_str(&function_body);

    code.push_str("}\n");

    Ok(code)
}

/// Generate struct creation code for multi-column results

/// Generate the function body using SQLx
fn generate_function_body(
    query: &QueryDefinition,
    type_info: &QueryTypeInfo,
    return_type: &str,
) -> Result<String> {
    let mut body = String::new();

    // Check if this query has conditional blocks
    if let Some(parsed_sql) = &type_info.parsed_sql {
        // Generate dynamic SQL building for conditional queries
        generate_conditional_function_body(&mut body, query, type_info, parsed_sql, return_type)?;
    } else {
        // Generate standard static SQL
        generate_static_function_body(&mut body, query, type_info, return_type)?;
    }

    Ok(body)
}

/// Generate function body for static (non-conditional) SQL queries
fn generate_static_function_body(
    body: &mut String,
    query: &QueryDefinition,
    type_info: &QueryTypeInfo,
    return_type: &str,
) -> Result<()> {
    let use_multiunzip = query.multiunzip;
    let use_conditional_diff = query.conditions_type.is_enabled();
    let use_structured_params = query.parameters_type.is_enabled() && !use_conditional_diff;
    // Add itertools import if using multiunzip
    if use_multiunzip {
        body.push_str("    use itertools::Itertools;\n");
    }

    // Convert named parameters to positional parameters for SQLx
    let (converted_sql, param_names) = convert_named_params_to_positional(&query.sql);

    // Build the SQLx query with parameter bindings
    let raw_string = generate_indented_raw_string_literal(&converted_sql);
    body.push_str(&format!(
        "    let query = sqlx::query(\n{}\n    );\n",
        raw_string
    ));

    // Add parameter bindings using method chaining
    if !type_info.input_types.is_empty() {
        if use_multiunzip {
            // Generate multiunzip pattern with struct field extraction

            // Get clean parameter names for field extraction
            let original_param_names = parse_parameter_names_from_sql(&query.sql);
            let clean_param_names: Vec<String> = original_param_names
                .iter()
                .map(|name| {
                    if name.ends_with('?') {
                        name.trim_end_matches('?').to_string()
                    } else {
                        name.clone()
                    }
                })
                .collect();

            // Generate the tuple pattern based on number of types
            let num_types = type_info.input_types.len();
            let tuple_vars: Vec<String> = clean_param_names
                .iter()
                .map(|name| {
                    // Convert to snake_case for consistency
                    to_snake_case(name)
                })
                .collect();
            let tuple_pattern = tuple_vars.join(", ");

            body.push_str(&format!(
                "    let ({}): ({}) =\n",
                tuple_pattern,
                vec!["Vec<_>"; num_types].join(", ")
            ));
            body.push_str("        items\n");
            body.push_str("            .into_iter()\n");

            // Generate the map closure to extract struct fields
            body.push_str(&format!(
                "            .map(|item| ({}))\n",
                tuple_vars
                    .iter()
                    .map(|field| format!("item.{}", field))
                    .collect::<Vec<_>>()
                    .join(", ")
            ));

            body.push_str("            .multiunzip();\n");

            // Bind each array
            for (i, var) in tuple_vars.iter().enumerate() {
                let rust_type_info = &type_info.input_types[i];

                if rust_type_info.needs_json_wrapper {
                    // For custom types in arrays, we need to serialize each element
                    body.push_str(&format!(
                        "    let {}_json: Result<Vec<serde_json::Value>, _> = {}.into_iter().map(|v| serde_json::to_value(&v)).collect();\n",
                        var, var
                    ));
                    body.push_str(&format!(
                        "    let query = query.bind({}_json.map_err(|e| sqlx::Error::Encode(Box::new(e)))?);\n",
                        var
                    ));
                } else {
                    body.push_str(&format!("    let query = query.bind({});\n", var));
                }
            }
        } else if use_structured_params {
            // For parameters_type, bind from params struct
            for (i, name) in param_names.iter().enumerate() {
                let clean_name = if name.ends_with('?') {
                    name.trim_end_matches('?').to_string()
                } else {
                    name.clone()
                };

                let rust_type_info = &type_info.input_types[i];
                let param_type = &rust_type_info.rust_type;

                // Check if this is a custom type that needs JSON serialization
                if rust_type_info.needs_json_wrapper {
                    // For custom types, serialize to JSON before binding
                    body.push_str(&format!(
                        "    let query = query.bind(serde_json::to_value(&params.{}).map_err(|e| sqlx::Error::Encode(Box::new(e)))?);\n", 
                        clean_name
                    ));
                } else if param_type == "String" {
                    // Use reference for String parameters to avoid move issues
                    body.push_str(&format!(
                        "    let query = query.bind(&params.{});\n",
                        clean_name
                    ));
                } else if rust_type_info.is_nullable {
                    // For Option types, we can bind directly
                    body.push_str(&format!(
                        "    let query = query.bind(params.{});\n",
                        clean_name
                    ));
                } else {
                    // For Copy types, we can bind directly
                    body.push_str(&format!(
                        "    let query = query.bind(params.{});\n",
                        clean_name
                    ));
                }
            }
        } else if param_names.is_empty() {
            // Fallback to generic param names
            for i in 1..=type_info.input_types.len() {
                body.push_str(&format!("    let query = query.bind(param_{});\n", i));
            }
        } else {
            // Use meaningful parameter names from SQL
            for (i, name) in param_names.iter().enumerate() {
                let clean_name = if name.ends_with('?') {
                    name.trim_end_matches('?').to_string()
                } else {
                    name.clone()
                };

                let rust_type_info = &type_info.input_types[i];
                let param_type = &rust_type_info.rust_type;

                // Check if this is a custom type that needs JSON serialization
                if rust_type_info.needs_json_wrapper {
                    // For custom types, serialize to JSON before binding
                    body.push_str(&format!(
                        "    let query = query.bind(serde_json::to_value(&{}).map_err(|e| sqlx::Error::Encode(Box::new(e)))?);\n", 
                        clean_name
                    ));
                } else if param_type == "String" {
                    // Use reference for String parameters to avoid move issues
                    body.push_str(&format!("    let query = query.bind(&{});\n", clean_name));
                } else {
                    body.push_str(&format!("    let query = query.bind({});\n", clean_name));
                }
            }
        }
    }

    generate_query_execution(body, query, type_info, return_type);
    Ok(())
}

/// Generate function body for conditional (dynamic) SQL queries
fn generate_conditional_function_body(
    body: &mut String,
    query: &QueryDefinition,
    type_info: &QueryTypeInfo,
    parsed_sql: &crate::types_extractor::ParsedSql,
    return_type: &str,
) -> Result<()> {
    use crate::types_extractor::parse_parameter_names_from_sql;

    let use_conditional_diff = query.conditions_type.is_enabled();
    let use_structured_params = query.parameters_type.is_enabled() && !use_conditional_diff;
    // Parse all parameters from the original SQL to get their order and types
    let all_params = parse_parameter_names_from_sql(&query.sql);

    // Track parameter count for proper numbering across all parts
    let mut current_param_num = 1usize;

    // Start with the base SQL template that has placeholders for conditional blocks
    let mut sql_template = parsed_sql.base_sql.clone();

    // Replace non-conditional parameters in the template with numbered placeholders
    for param_name in parse_parameter_names_from_sql(&parsed_sql.base_sql) {
        if !param_name.ends_with('?') {
            // Only replace non-conditional parameters
            sql_template = sql_template.replace(
                &format!("${{{}}}", param_name),
                &format!("${}", current_param_num),
            );
            current_param_num += 1;
        }
    }

    // Create conditional block info (without fixed parameter numbers)
    let mut conditional_replacements = Vec::new();
    for (i, block) in parsed_sql.conditional_blocks.iter().enumerate() {
        if !block.parameters.is_empty() {
            let first_param = &block.parameters[0];
            let block_sql = block.sql_content.clone(); // Keep original parameter syntax for now
            conditional_replacements.push((i, block_sql, first_param.clone()));
        }
    }

    // Generate the SQL building code with complete parameter renumbering
    body.push_str("    let mut final_sql = r\"");
    body.push_str(&sql_template);
    body.push_str("\".to_string();\n");
    body.push_str("    let mut included_params = Vec::new();\n\n");

    // Replace each conditional block based on parameter presence or diff
    for (_, block_sql, param_name) in &conditional_replacements {
        let clean_param = if param_name.ends_with('?') {
            param_name.trim_end_matches('?')
        } else {
            param_name
        };

        let conditional_block = format!("$[{}]", block_sql);

        if use_conditional_diff {
            // For conditions_type, check if old and new values differ
            body.push_str(&format!(
                "    if old.{} != new.{} {{\n",
                clean_param, clean_param
            ));
        } else if use_structured_params {
            // For parameters_type, check if parameter is Some (for Option types)
            body.push_str(&format!("    if params.{}.is_some() {{\n", clean_param));
        } else {
            // For regular conditional, check if parameter is Some
            body.push_str(&format!("    if {}.is_some() {{\n", clean_param));
        }

        body.push_str(&format!(
            "        final_sql = final_sql.replace(r\"{}\", r\"{}\");\n",
            conditional_block,
            &conditional_block[2..conditional_block.len() - 1]
        ));
        body.push_str(&format!(
            "        included_params.push(\"{}\");\n",
            clean_param
        ));
        body.push_str("    } else {\n");
        body.push_str(&format!(
            "        final_sql = final_sql.replace(r\"{}\", \"\");\n",
            conditional_block
        ));
        body.push_str("    }\n\n");
    }

    body.push_str("    #[allow(unused_assignments)]\n");
    body.push_str("    let mut param_counter = 1;\n");

    // Renumber base (non-conditional) parameters first
    for param_name in parse_parameter_names_from_sql(&parsed_sql.base_sql) {
        if !param_name.ends_with('?') {
            body.push_str(&format!(
                "    final_sql = final_sql.replace(r\"${{{}}}\", &format!(\"${{}}\", param_counter));\n",
                param_name
            ));
            body.push_str("    param_counter += 1;\n");
        }
    }

    // Renumber conditional parameters that are included
    for (_, _, param_name) in &conditional_replacements {
        let clean_param = if param_name.ends_with('?') {
            param_name.trim_end_matches('?')
        } else {
            param_name
        };

        body.push_str(&format!(
            "    if included_params.contains(&r\"{}\") {{\n",
            clean_param
        ));
        body.push_str(&format!(
            "        final_sql = final_sql.replace(r\"${{{}}}\", &format!(\"${{}}\", param_counter));\n",
            param_name
        ));
        body.push_str("        param_counter += 1;\n");
        body.push_str("    }\n");
    }

    // Ensure param_counter is marked as used to avoid unused assignment warnings
    body.push_str("    let _ = param_counter; // Suppress unused assignment warning\n");
    body.push_str("\n    let mut query = sqlx::query(&final_sql);\n\n");

    // Bind parameters in the order they will appear in the final SQL
    // First, bind base (non-conditional) parameters
    for param_name in parse_parameter_names_from_sql(&parsed_sql.base_sql) {
        if !param_name.ends_with('?') {
            // Only bind non-conditional parameters
            let clean_param = param_name.clone();

            if let Some(param_index) = all_params.iter().position(|p| {
                let clean_p = if p.ends_with('?') {
                    p.trim_end_matches('?')
                } else {
                    p
                };
                clean_p == clean_param
            }) {
                if let Some(rust_type_info) = type_info.input_types.get(param_index) {
                    if rust_type_info.needs_json_wrapper {
                        if use_structured_params {
                            body.push_str(&format!("    let {}_json = serde_json::to_value(&params.{}).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;\n", clean_param, clean_param));
                        } else {
                            body.push_str(&format!("    let {}_json = serde_json::to_value(&{}).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;\n", clean_param, clean_param));
                        }
                        body.push_str(&format!("    query = query.bind({}_json);\n", clean_param));
                    } else {
                        if use_structured_params {
                            body.push_str(&format!(
                                "    query = query.bind(&params.{});\n",
                                clean_param
                            ));
                        } else {
                            body.push_str(&format!("    query = query.bind(&{});\n", clean_param));
                        }
                    }
                }
            }
        }
    }

    // Then, bind conditional parameters only if they are included
    for (_, _, param_name) in &conditional_replacements {
        let clean_param = if param_name.ends_with('?') {
            param_name.trim_end_matches('?')
        } else {
            param_name
        };

        body.push_str(&format!(
            "    if included_params.contains(&r\"{}\") {{\n",
            clean_param
        ));

        if let Some(param_index) = all_params.iter().position(|p| {
            let clean_p = if p.ends_with('?') {
                p.trim_end_matches('?')
            } else {
                p
            };
            clean_p == clean_param
        }) {
            if let Some(rust_type_info) = type_info.input_types.get(param_index) {
                if rust_type_info.needs_json_wrapper {
                    if use_conditional_diff {
                        // For conditions_type, use new.field directly
                        body.push_str(&format!("        let {}_json = serde_json::to_value(&new.{}).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;\n", clean_param, clean_param));
                    } else if use_structured_params {
                        // For parameters_type, unwrap from params struct
                        body.push_str(&format!("        let {}_json = serde_json::to_value(&params.{}.as_ref().unwrap()).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;\n", clean_param, clean_param));
                    } else {
                        // For regular conditional, unwrap the Option
                        body.push_str(&format!("        let {}_json = serde_json::to_value(&{}.as_ref().unwrap()).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;\n", clean_param, clean_param));
                    }
                    body.push_str(&format!(
                        "        query = query.bind({}_json);\n",
                        clean_param
                    ));
                } else {
                    if use_conditional_diff {
                        // For conditions_type, bind new.field directly
                        body.push_str(&format!(
                            "        query = query.bind(&new.{});\n",
                            clean_param
                        ));
                    } else if use_structured_params {
                        // For parameters_type, unwrap from params struct
                        body.push_str(&format!(
                            "        query = query.bind(params.{}.as_ref().unwrap());\n",
                            clean_param
                        ));
                    } else {
                        // For regular conditional, unwrap the Option
                        body.push_str(&format!(
                            "        query = query.bind({}.as_ref().unwrap());\n",
                            clean_param
                        ));
                    }
                }
            }
        }

        body.push_str("    }\n\n");
    }

    generate_query_execution(body, query, type_info, return_type);
    Ok(())
}
/// Generate the query execution part (common for both static and conditional queries)
fn generate_query_execution(
    body: &mut String,
    query: &QueryDefinition,
    type_info: &QueryTypeInfo,
    return_type: &str,
) {
    // Always use .map_err(Into::into) since both Error<C> and ErrorReadOnly have From<sqlx::Error>
    let map_err_suffix = ".map_err(Into::into)";

    if type_info.output_types.is_empty() {
        // For queries that don't return data (INSERT, UPDATE, DELETE)
        body.push_str("    query.execute(executor).await?;\n");
        body.push_str("    Ok(())\n");
    } else if type_info.output_types.len() == 1 {
        // For queries that return a single column
        match query.expect {
            ExpectedResult::ExactlyOne => {
                body.push_str("    let row = query.fetch_one(executor).await?;\n");
                let value_extraction =
                    generate_sqlx_value_extraction(&type_info.output_types[0], 0);
                body.push_str(&format!("    Ok({})\n", value_extraction));
            }
            ExpectedResult::PossibleOne => {
                body.push_str("    let row = query.fetch_optional(executor).await?;\n");
                body.push_str("    match row {\n");
                body.push_str("        Some(row) => {\n");
                let value_extraction =
                    generate_sqlx_value_extraction(&type_info.output_types[0], 0);
                if type_info.output_types[0].rust_type.is_nullable {
                    body.push_str(&format!("            Ok({})\n", value_extraction));
                } else {
                    body.push_str(&format!("            Ok(Some({}))\n", value_extraction));
                }
                body.push_str("        },\n");
                body.push_str("        None => Ok(None),\n");
                body.push_str("    }\n");
            }
            ExpectedResult::AtLeastOne => {
                body.push_str("    let rows = query.fetch_all(executor).await?;\n");
                body.push_str("    if rows.is_empty() {\n");
                body.push_str("        return Err(sqlx::Error::RowNotFound.into());\n");
                body.push_str("    }\n");
                body.push_str(
                    "    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {\n",
                );
                let value_extraction =
                    generate_sqlx_value_extraction(&type_info.output_types[0], 0);
                body.push_str(&format!("        Ok({})\n", value_extraction));
                body.push_str("    }).collect();\n");
                body.push_str(&format!("    result{}\n", map_err_suffix));
            }
            ExpectedResult::Multiple => {
                body.push_str("    let rows = query.fetch_all(executor).await?;\n");
                body.push_str(
                    "    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {\n",
                );
                let value_extraction =
                    generate_sqlx_value_extraction(&type_info.output_types[0], 0);
                body.push_str(&format!("        Ok({})\n", value_extraction));
                body.push_str("    }).collect();\n");
                body.push_str(&format!("    result{}\n", map_err_suffix));
            }
        }
    } else {
        // For queries that return multiple columns
        match query.expect {
            ExpectedResult::ExactlyOne => {
                body.push_str("    let row = query.fetch_one(executor).await?;\n");
                body.push_str("    let result: Result<_, sqlx::Error> = (|| {\n");
                let struct_creation =
                    generate_sqlx_struct_creation(return_type, &type_info.output_types);
                body.push_str(&format!("        Ok({})\n", struct_creation));
                body.push_str("    })();\n");
                body.push_str(&format!("    result{}\n", map_err_suffix));
            }
            ExpectedResult::PossibleOne => {
                body.push_str("    let row = query.fetch_optional(executor).await?;\n");
                body.push_str("    match row {\n");
                body.push_str("        Some(row) => {\n");
                body.push_str("            let result: Result<_, sqlx::Error> = (|| {\n");
                let struct_creation =
                    generate_sqlx_struct_creation(return_type, &type_info.output_types);
                body.push_str(&format!("                Ok({})\n", struct_creation));
                body.push_str("            })();\n");
                body.push_str(&format!("            result.map(Some){}\n", map_err_suffix));
                body.push_str("        },\n");
                body.push_str("        None => Ok(None),\n");
                body.push_str("    }\n");
            }
            ExpectedResult::AtLeastOne => {
                body.push_str("    let rows = query.fetch_all(executor).await?;\n");
                body.push_str("    if rows.is_empty() {\n");
                body.push_str("        return Err(sqlx::Error::RowNotFound.into());\n");
                body.push_str("    }\n");
                body.push_str(
                    "    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {\n",
                );
                let struct_creation =
                    generate_sqlx_struct_creation(return_type, &type_info.output_types);
                body.push_str(&format!("        Ok({})\n", struct_creation));
                body.push_str("    }).collect();\n");
                body.push_str(&format!("    result{}\n", map_err_suffix));
            }
            ExpectedResult::Multiple => {
                body.push_str("    let rows = query.fetch_all(executor).await?;\n");
                body.push_str(
                    "    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {\n",
                );
                let struct_creation =
                    generate_sqlx_struct_creation(return_type, &type_info.output_types);
                body.push_str(&format!("        Ok({})\n", struct_creation));
                body.push_str("    }).collect();\n");
                body.push_str(&format!("    result{}\n", map_err_suffix));
            }
        }
    }
}

/// Generate SQLx value extraction for a single column
fn generate_sqlx_value_extraction(output_col: &OutputColumn, _index: usize) -> String {
    let column_name = &output_col.name;

    if output_col.rust_type.needs_json_wrapper {
        // For custom types, we need to extract as serde_json::Value and then deserialize
        let inner_type = &output_col.rust_type.rust_type;
        if output_col.rust_type.is_nullable {
            format!(
                "row.try_get::<Option<serde_json::Value>, _>(\"{}\")?
            .map(|v| serde_json::from_value::<{}>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?",
                column_name, inner_type
            )
        } else {
            format!(
                "serde_json::from_value::<{}>(
            row.try_get::<serde_json::Value, _>(\"{}\")?)
            .map_err(|e| sqlx::Error::Decode(Box::new(e)))?",
                inner_type, column_name
            )
        }
    } else {
        // For standard types, extract directly
        if output_col.rust_type.is_nullable {
            format!(
                "row.try_get::<Option<{}>, _>(\"{}\")?",
                output_col.rust_type.rust_type, column_name
            )
        } else {
            format!(
                "row.try_get::<{}, _>(\"{}\")?",
                output_col.rust_type.rust_type, column_name
            )
        }
    }
}

/// Generate SQLx struct creation code for multi-column results
fn generate_sqlx_struct_creation(struct_name: &str, output_types: &[OutputColumn]) -> String {
    let mut creation = format!("{} {{\n", struct_name);

    for (i, col) in output_types.iter().enumerate() {
        let field_name = to_snake_case(&col.name);
        let value_extraction = generate_sqlx_value_extraction(col, i);
        creation.push_str(&format!("        {}: {},\n", field_name, value_extraction));
    }

    creation.push_str("    }");
    creation
}

/// Validates that a referenced struct exists and has matching parameter fields
/// Returns Ok if validation passes, Err with a descriptive message if not
pub fn validate_struct_reference(
    struct_name: &str,
    query_params: &[String],
    query_param_types: &[crate::types_extractor::RustType],
    available_structs: &std::collections::HashMap<String, Vec<(String, String)>>,
    is_conditional_diff: bool,
) -> Result<()> {
    // Check if the struct exists
    let struct_fields = available_structs.get(struct_name).ok_or_else(|| {
        anyhow::anyhow!(
            "Referenced struct '{}' does not exist. Make sure it's defined by a previous query (either via parameters_type: true for params structs, or as a return type for multi-column queries)",
            struct_name
        )
    })?;

    // Build a map of query parameters for comparison
    let mut query_field_map: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();
    for (i, param_name) in query_params.iter().enumerate() {
        let clean_param = param_name.trim_end_matches('?');
        if let Some(param_type) = query_param_types.get(i) {
            let type_str = if param_type.is_nullable || param_type.is_optional {
                format!("Option<{}>", param_type.rust_type)
            } else {
                param_type.rust_type.clone()
            };
            query_field_map.insert(clean_param.to_string(), type_str);
        }
    }

    // Check if all query parameters exist in the struct with matching types
    for (param_name, param_type) in &query_field_map {
        let struct_field = struct_fields
            .iter()
            .find(|(name, _)| name == param_name)
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "Query parameter '{}' not found in struct '{}'. Available fields: {}",
                    param_name,
                    struct_name,
                    struct_fields
                        .iter()
                        .map(|(n, _)| n.as_str())
                        .collect::<Vec<_>>()
                        .join(", ")
                )
            })?;

        // For conditional diff, allow flexible type matching
        // The struct can have String while query has Option<String>, since we're comparing old vs new
        let types_match = if is_conditional_diff {
            // Check if types are compatible: exact match OR struct is non-nullable and query is nullable
            &struct_field.1 == param_type
                || (param_type.starts_with("Option<")
                    && param_type.ends_with(">")
                    && &struct_field.1 == &param_type[7..param_type.len() - 1])
        } else {
            // For non-conditional, require exact match
            &struct_field.1 == param_type
        };

        if !types_match {
            anyhow::bail!(
                "Type mismatch for parameter '{}' in struct '{}': expected '{}', but query requires '{}'",
                param_name,
                struct_name,
                struct_field.1,
                param_type
            );
        }
    }

    Ok(())
}
