// This file was auto-generated by automodel
// Do not edit manually

use tokio_postgres::{Client, Error};
use std::result::Result;

/// Retrieve a user by their ID
/// Generated from SQL: SELECT id, name, email, created_at FROM users WHERE id = $1
#[derive(Debug, Clone)]
pub struct GetUserByIdResult {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub created_at: Option<chrono::NaiveDateTime>,
}

pub async fn get_user_by_id(client: &tokio_postgres::Client, param_1: i32) -> Result<GetUserByIdResult, tokio_postgres::Error> {
    let stmt = client.prepare("SELECT id, name, email, created_at FROM users WHERE id = $1").await?;
    let row = client.query_one(&stmt, &[&param_1]).await?;
    Ok(GetUserByIdResult {
        id: row.get::<_, i32>(0),
        name: row.get::<_, String>(1),
        email: row.get::<_, String>(2),
        created_at: row.get::<_, Option<chrono::NaiveDateTime>>(3),
    })
}

/// List all active users ordered by name
/// Generated from SQL: SELECT id, name, email FROM users WHERE is_active = true ORDER BY name
#[derive(Debug, Clone)]
pub struct ListActiveUsersResult {
    pub id: i32,
    pub name: String,
    pub email: String,
}

pub async fn list_active_users(client: &tokio_postgres::Client) -> Result<ListActiveUsersResult, tokio_postgres::Error> {
    let stmt = client.prepare("SELECT id, name, email FROM users WHERE is_active = true ORDER BY name").await?;
    let row = client.query_one(&stmt, &[]).await?;
    Ok(ListActiveUsersResult {
        id: row.get::<_, i32>(0),
        name: row.get::<_, String>(1),
        email: row.get::<_, String>(2),
    })
}

/// Create a new user and return the generated ID
/// Generated from SQL: INSERT INTO users (name, email, is_active) VALUES ($1, $2, $3) RETURNING id
pub async fn create_user(client: &tokio_postgres::Client, param_1: String, param_2: String, param_3: bool) -> Result<i32, tokio_postgres::Error> {
    let stmt = client.prepare("INSERT INTO users (name, email, is_active) VALUES ($1, $2, $3) RETURNING id").await?;
    let row = client.query_one(&stmt, &[&param_1, &param_2, &param_3]).await?;
    Ok(row.get::<_, i32>(0))
}

/// Update a user's email address
/// Generated from SQL: UPDATE users SET email = $2, updated_at = NOW() WHERE id = $1
pub async fn update_user_email(client: &tokio_postgres::Client, param_1: i32, param_2: String) -> Result<(), tokio_postgres::Error> {
    let stmt = client.prepare("UPDATE users SET email = $2, updated_at = NOW() WHERE id = $1").await?;
    client.execute(&stmt, &[&param_1, &param_2]).await?;
    Ok(())
}

/// Delete a user by ID
/// Generated from SQL: DELETE FROM users WHERE id = $1
pub async fn delete_user(client: &tokio_postgres::Client, param_1: i32) -> Result<(), tokio_postgres::Error> {
    let stmt = client.prepare("DELETE FROM users WHERE id = $1").await?;
    client.execute(&stmt, &[&param_1]).await?;
    Ok(())
}
