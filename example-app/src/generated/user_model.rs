// This file was automatically generated by AutoModel. Do not edit manually.

use sqlx::Row;

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UserContentConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UserContentConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct UserModel {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
}

/// Insert a new user and return as UserModel
#[tracing::instrument(level = "debug", skip_all, fields(sql = "INSERT INTO public.users (name, email, age) \nVALUES (${name}, ${email}, ${age?}) \nRETURNING id, name, email, age"))]
pub async fn create_user(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name: String, email: String, age: Option<i32>) -> Result<UserModel, super::Error<UserContentConstraints>> {
    let query = sqlx::query(
        r"INSERT INTO public.users (name, email, age) 
        VALUES ($1, $2, $3) 
        RETURNING id, name, email, age"
    );
    let query = query.bind(&name);
    let query = query.bind(&email);
    let query = query.bind(age);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    })();
    result.map_err(Into::into)
}

/// Full update of user - reuses UserModel for both parameters and return type
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET name = ${name}, email = ${email}, age = ${age?} \nWHERE id = ${id} \nRETURNING id, name, email, age"))]
pub async fn update_user_full(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &UserModel) -> Result<UserModel, super::Error<UserContentConstraints>> {
    let query = sqlx::query(
        r"UPDATE public.users 
        SET name = $1, email = $2, age = $3 
        WHERE id = $4 
        RETURNING id, name, email, age"
    );
    let query = query.bind(&params.name);
    let query = query.bind(&params.email);
    let query = query.bind(params.age);
    let query = query.bind(params.id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    })();
    result.map_err(Into::into)
}

/// Partial update using diff-based comparison - auto-generates params struct for old/new comparison
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET updated_at = NOW() \n$[, name = ${name?}] \n$[, email = ${email?}] \n$[, age = ${age?}] \nWHERE id = ${id} \nRETURNING id, name, email, age"))]
pub async fn update_user_partial(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, old: &UserModel, new: &UserModel, id: i32) -> Result<UserModel, super::Error<UserContentConstraints>> {
    let mut final_sql = r"UPDATE public.users 
SET updated_at = NOW() 
$[, name = ${name?}] 
$[, email = ${email?}] 
$[, age = ${age?}] 
WHERE id = $1 
RETURNING id, name, email, age".to_string();
    let mut included_params = Vec::new();

    if old.name != new.name {
        final_sql = final_sql.replace(r"$[, name = ${name?}]", r", name = ${name?}");
        included_params.push("name");
    } else {
        final_sql = final_sql.replace(r"$[, name = ${name?}]", "");
    }

    if old.email != new.email {
        final_sql = final_sql.replace(r"$[, email = ${email?}]", r", email = ${email?}");
        included_params.push("email");
    } else {
        final_sql = final_sql.replace(r"$[, email = ${email?}]", "");
    }

    if old.age != new.age {
        final_sql = final_sql.replace(r"$[, age = ${age?}]", r", age = ${age?}");
        included_params.push("age");
    } else {
        final_sql = final_sql.replace(r"$[, age = ${age?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"${id}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"name") {
        final_sql = final_sql.replace(r"${name?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"email") {
        final_sql = final_sql.replace(r"${email?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"age") {
        final_sql = final_sql.replace(r"${age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    query = query.bind(&id);
    if included_params.contains(&r"name") {
        query = query.bind(&new.name);
    }

    if included_params.contains(&r"email") {
        query = query.bind(&new.email);
    }

    if included_params.contains(&r"age") {
        query = query.bind(&new.age);
    }

    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    })();
    result.map_err(Into::into)
}

/// Select user by email - returns UserModel
///
/// Query Plan:
/// Index Scan using users_email_key on users  (cost=0.14..8.16 rows=1 width=56)
///   Index Cond: ((email)::text = 'dummy'::text)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age \nFROM public.users \nWHERE email = ${email}"))]
pub async fn find_user_by_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, email: String) -> Result<Option<UserModel>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age 
        FROM public.users 
        WHERE email = $1"
    );
    let query = query.bind(&email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

