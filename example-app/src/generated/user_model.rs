// AUTOMODEL_HASH: 2539049994705522070
// This file was automatically generated by AutoModel. Do not edit manually.

use sqlx::Row;

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UserContentConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
    /// Unknown constraint violation
    Unknown {
        constraint_name: String,
        table_name: String,
    },
}

impl From<super::ErrorConstraintInfo> for UserContentConstraints {
    fn from(info: super::ErrorConstraintInfo) -> Self {
        match info.constraint_name.as_str() {
            "users_email_key" => Self::UsersEmailKey,
            "users_pkey" => Self::UsersPkey,
            "users_referrer_id_fkey" => Self::UsersReferrerIdFkey,
            "users_id_not_null" => Self::UsersIdNotNull,
            "users_name_not_null" => Self::UsersNameNotNull,
            "users_email_not_null" => Self::UsersEmailNotNull,
            _ => Self::Unknown {
                constraint_name: info.constraint_name,
                table_name: info.table_name,
            },
        }
    }
}

#[derive(Debug, Clone)]
pub struct UserModel {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
}

/// Insert a new user and return as UserModel
#[tracing::instrument(level = "debug", skip_all, fields(sql = "INSERT INTO users (name, email, age) VALUES (${name}, ${email}, ${age?}) RETURNING id, name, email, age"))]
pub async fn create_user(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name: String, email: String, age: Option<i32>) -> Result<UserModel, super::Error<UserContentConstraints>> {
    let query = sqlx::query(
        r"INSERT INTO users (name, email, age) VALUES ($1, $2, $3) RETURNING id, name, email, age"
    );
    let query = query.bind(&name);
    let query = query.bind(&email);
    let query = query.bind(age);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    })();
    result.map_err(Into::into)
}

/// Full update of user - reuses UserModel for both parameters and return type
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE users SET name = ${name}, email = ${email}, age = ${age?} WHERE id = ${id} RETURNING id, name, email, age"))]
pub async fn update_user_full(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &UserModel) -> Result<UserModel, super::Error<UserContentConstraints>> {
    let query = sqlx::query(
        r"UPDATE users SET name = $1, email = $2, age = $3 WHERE id = $4 RETURNING id, name, email, age"
    );
    let query = query.bind(&params.name);
    let query = query.bind(&params.email);
    let query = query.bind(params.age);
    let query = query.bind(params.id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    })();
    result.map_err(Into::into)
}

/// Partial update using diff-based comparison - auto-generates params struct for old/new comparison 
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE users SET updated_at = NOW() $[, name = ${name?}] $[, email = ${email?}] $[, age = ${age?}] WHERE id = ${id} RETURNING id, name, email, age"))]
pub async fn update_user_partial(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, old: &UserModel, new: &UserModel, id: i32) -> Result<UserModel, super::Error<UserContentConstraints>> {
    let mut final_sql = r"UPDATE users SET updated_at = NOW() $[, name = ${name?}] $[, email = ${email?}] $[, age = ${age?}] WHERE id = $1 RETURNING id, name, email, age".to_string();
    let mut included_params = Vec::new();

    if old.name != new.name {
        final_sql = final_sql.replace(r"$[, name = ${name?}]", r", name = ${name?}");
        included_params.push("name");
    } else {
        final_sql = final_sql.replace(r"$[, name = ${name?}]", "");
    }

    if old.email != new.email {
        final_sql = final_sql.replace(r"$[, email = ${email?}]", r", email = ${email?}");
        included_params.push("email");
    } else {
        final_sql = final_sql.replace(r"$[, email = ${email?}]", "");
    }

    if old.age != new.age {
        final_sql = final_sql.replace(r"$[, age = ${age?}]", r", age = ${age?}");
        included_params.push("age");
    } else {
        final_sql = final_sql.replace(r"$[, age = ${age?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"${id}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"name") {
        final_sql = final_sql.replace(r"${name?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"email") {
        final_sql = final_sql.replace(r"${email?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"age") {
        final_sql = final_sql.replace(r"${age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    query = query.bind(&id);
    if included_params.contains(&r"name") {
        query = query.bind(&new.name);
    }

    if included_params.contains(&r"email") {
        query = query.bind(&new.email);
    }

    if included_params.contains(&r"age") {
        query = query.bind(&new.age);
    }

    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    })();
    result.map_err(Into::into)
}

/// Select user by email - returns UserModel
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age FROM users WHERE email = ${email}"))]
pub async fn find_user_by_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, email: String) -> Result<Option<UserModel>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age FROM users WHERE email = $1"
    );
    let query = query.bind(&email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(UserModel {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

