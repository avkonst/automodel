// AUTOMODEL_HASH: 2158760966342928331
// This file was automatically generated by AutoModel. Do not edit manually.

use sqlx::Row;

/// Get the current server timestamp
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT NOW() as current_time"))]
pub async fn get_current_time(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Option<chrono::DateTime<chrono::Utc>>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT NOW() as current_time"
    );
    let row = query.fetch_one(executor).await?;
    Ok(row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("current_time")?)
}

/// Get PostgreSQL version
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT version() as pg_version"))]
pub async fn get_version(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Option<String>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT version() as pg_version"
    );
    let row = query.fetch_one(executor).await?;
    Ok(row.try_get::<Option<String>, _>("pg_version")?)
}

/// Insert a row with all PostgreSQL types
#[tracing::instrument(level = "debug", skip_all, fields(sql = "INSERT INTO all_types_test (\n  bool_col, char_col, int2_col, int4_col, int8_col, float4_col, float8_col, numeric_col,\n  name_col, text_col, varchar_col, bpchar_col, bytea_col, bit_col, varbit_col,\n  date_col, time_col, timestamp_col, timestamptz_col, interval_col, timetz_col,\n  int4_range_col, int8_range_col, num_range_col, ts_range_col, tstz_range_col, date_range_col,\n  inet_col, cidr_col, macaddr_col, json_col, jsonb_col, uuid_col,\n  bool_array_col, int4_array_col, int8_array_col, text_array_col, float8_array_col,\n  int4_range_array_col, date_range_array_col\n) VALUES (\n  ${bool_col}, ${char_col}, ${int2_col}, ${int4_col}, ${int8_col}, ${float4_col}, ${float8_col}, ${numeric_col},\n  ${name_col}, ${text_col}, ${varchar_col}, ${bpchar_col}, ${bytea_col}, ${bit_col}, ${varbit_col},\n  ${date_col}, ${time_col}, ${timestamp_col}, ${timestamptz_col}, ${interval_col}, ${timetz_col},\n  ${int4_range_col}, ${int8_range_col}, ${num_range_col}, ${ts_range_col}, ${tstz_range_col}, ${date_range_col},\n  ${inet_col}, ${cidr_col}, ${macaddr_col}, ${json_col}, ${jsonb_col}, ${uuid_col},\n  ${bool_array_col}, ${int4_array_col}, ${int8_array_col}, ${text_array_col}, ${float8_array_col},\n  ${int4_range_array_col}, ${date_range_array_col}\n)\nRETURNING id\n"))]
pub async fn insert_all_types_test(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, bool_col: bool, char_col: String, int2_col: i16, int4_col: i32, int8_col: i64, float4_col: f32, float8_col: f64, numeric_col: rust_decimal::Decimal, name_col: String, text_col: String, varchar_col: String, bpchar_col: String, bytea_col: Vec<u8>, bit_col: bit_vec::BitVec, varbit_col: bit_vec::BitVec, date_col: chrono::NaiveDate, time_col: chrono::NaiveTime, timestamp_col: chrono::NaiveDateTime, timestamptz_col: chrono::DateTime<chrono::Utc>, interval_col: sqlx::postgres::types::PgInterval, timetz_col: sqlx::postgres::types::PgTimeTz, int4_range_col: sqlx::postgres::types::PgRange<i32>, int8_range_col: sqlx::postgres::types::PgRange<i64>, num_range_col: sqlx::postgres::types::PgRange<rust_decimal::Decimal>, ts_range_col: sqlx::postgres::types::PgRange<chrono::NaiveDateTime>, tstz_range_col: sqlx::postgres::types::PgRange<chrono::DateTime<chrono::Utc>>, date_range_col: sqlx::postgres::types::PgRange<chrono::NaiveDate>, inet_col: std::net::IpAddr, cidr_col: std::net::IpAddr, macaddr_col: mac_address::MacAddress, json_col: serde_json::Value, jsonb_col: serde_json::Value, uuid_col: uuid::Uuid, bool_array_col: Vec<bool>, int4_array_col: Vec<i32>, int8_array_col: Vec<i64>, text_array_col: Vec<String>, float8_array_col: Vec<f64>, int4_range_array_col: Vec<sqlx::postgres::types::PgRange<i32>>, date_range_array_col: Vec<sqlx::postgres::types::PgRange<chrono::NaiveDate>>) -> Result<i32, sqlx::Error> {
    let query = sqlx::query(
        r"INSERT INTO all_types_test (
          bool_col, char_col, int2_col, int4_col, int8_col, float4_col, float8_col, numeric_col,
          name_col, text_col, varchar_col, bpchar_col, bytea_col, bit_col, varbit_col,
          date_col, time_col, timestamp_col, timestamptz_col, interval_col, timetz_col,
          int4_range_col, int8_range_col, num_range_col, ts_range_col, tstz_range_col, date_range_col,
          inet_col, cidr_col, macaddr_col, json_col, jsonb_col, uuid_col,
          bool_array_col, int4_array_col, int8_array_col, text_array_col, float8_array_col,
          int4_range_array_col, date_range_array_col
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8,
          $9, $10, $11, $12, $13, $14, $15,
          $16, $17, $18, $19, $20, $21,
          $22, $23, $24, $25, $26, $27,
          $28, $29, $30, $31, $32, $33,
          $34, $35, $36, $37, $38,
          $39, $40
        )
        RETURNING id"
    );
    let query = query.bind(bool_col);
    let query = query.bind(&char_col);
    let query = query.bind(int2_col);
    let query = query.bind(int4_col);
    let query = query.bind(int8_col);
    let query = query.bind(float4_col);
    let query = query.bind(float8_col);
    let query = query.bind(numeric_col);
    let query = query.bind(&name_col);
    let query = query.bind(&text_col);
    let query = query.bind(&varchar_col);
    let query = query.bind(&bpchar_col);
    let query = query.bind(bytea_col);
    let query = query.bind(bit_col);
    let query = query.bind(varbit_col);
    let query = query.bind(date_col);
    let query = query.bind(time_col);
    let query = query.bind(timestamp_col);
    let query = query.bind(timestamptz_col);
    let query = query.bind(interval_col);
    let query = query.bind(timetz_col);
    let query = query.bind(int4_range_col);
    let query = query.bind(int8_range_col);
    let query = query.bind(num_range_col);
    let query = query.bind(ts_range_col);
    let query = query.bind(tstz_range_col);
    let query = query.bind(date_range_col);
    let query = query.bind(inet_col);
    let query = query.bind(cidr_col);
    let query = query.bind(macaddr_col);
    let query = query.bind(json_col);
    let query = query.bind(jsonb_col);
    let query = query.bind(uuid_col);
    let query = query.bind(bool_array_col);
    let query = query.bind(int4_array_col);
    let query = query.bind(int8_array_col);
    let query = query.bind(text_array_col);
    let query = query.bind(float8_array_col);
    let query = query.bind(int4_range_array_col);
    let query = query.bind(date_range_array_col);
    let row = query.fetch_one(executor).await?;
    Ok(row.try_get::<i32, _>("id")?)
}

#[derive(Debug, Clone)]
pub struct GetAllTypesTestItem {
    pub id: i32,
    pub bool_col: Option<bool>,
    pub char_col: Option<String>,
    pub int2_col: Option<i16>,
    pub int4_col: Option<i32>,
    pub int8_col: Option<i64>,
    pub float4_col: Option<f32>,
    pub float8_col: Option<f64>,
    pub numeric_col: Option<rust_decimal::Decimal>,
    pub name_col: Option<String>,
    pub text_col: Option<String>,
    pub varchar_col: Option<String>,
    pub bpchar_col: Option<String>,
    pub bytea_col: Option<Vec<u8>>,
    pub bit_col: Option<bit_vec::BitVec>,
    pub varbit_col: Option<bit_vec::BitVec>,
    pub date_col: Option<chrono::NaiveDate>,
    pub time_col: Option<chrono::NaiveTime>,
    pub timestamp_col: Option<chrono::NaiveDateTime>,
    pub timestamptz_col: Option<chrono::DateTime<chrono::Utc>>,
    pub interval_col: Option<sqlx::postgres::types::PgInterval>,
    pub timetz_col: Option<sqlx::postgres::types::PgTimeTz>,
    pub int4_range_col: Option<sqlx::postgres::types::PgRange<i32>>,
    pub int8_range_col: Option<sqlx::postgres::types::PgRange<i64>>,
    pub num_range_col: Option<sqlx::postgres::types::PgRange<rust_decimal::Decimal>>,
    pub ts_range_col: Option<sqlx::postgres::types::PgRange<chrono::NaiveDateTime>>,
    pub tstz_range_col: Option<sqlx::postgres::types::PgRange<chrono::DateTime<chrono::Utc>>>,
    pub date_range_col: Option<sqlx::postgres::types::PgRange<chrono::NaiveDate>>,
    pub inet_col: Option<std::net::IpAddr>,
    pub cidr_col: Option<std::net::IpAddr>,
    pub macaddr_col: Option<mac_address::MacAddress>,
    pub json_col: Option<serde_json::Value>,
    pub jsonb_col: Option<serde_json::Value>,
    pub uuid_col: Option<uuid::Uuid>,
    pub bool_array_col: Option<Vec<bool>>,
    pub int4_array_col: Option<Vec<i32>>,
    pub int8_array_col: Option<Vec<i64>>,
    pub text_array_col: Option<Vec<String>>,
    pub float8_array_col: Option<Vec<f64>>,
    pub int4_range_array_col: Option<Vec<sqlx::postgres::types::PgRange<i32>>>,
    pub date_range_array_col: Option<Vec<sqlx::postgres::types::PgRange<chrono::NaiveDate>>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get a row with all PostgreSQL types by ID
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT\n  id, bool_col, char_col, int2_col, int4_col, int8_col, float4_col, float8_col, numeric_col,\n  name_col, text_col, varchar_col, bpchar_col, bytea_col, bit_col, varbit_col,\n  date_col, time_col, timestamp_col, timestamptz_col, interval_col, timetz_col,\n  int4_range_col, int8_range_col, num_range_col, ts_range_col, tstz_range_col, date_range_col,\n  inet_col, cidr_col, macaddr_col, json_col, jsonb_col, uuid_col,\n  bool_array_col, int4_array_col, int8_array_col, text_array_col, float8_array_col,\n  int4_range_array_col, date_range_array_col,\n  created_at\nFROM all_types_test\nWHERE id = ${id}\n"))]
pub async fn get_all_types_test(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, id: i32) -> Result<GetAllTypesTestItem, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT
          id, bool_col, char_col, int2_col, int4_col, int8_col, float4_col, float8_col, numeric_col,
          name_col, text_col, varchar_col, bpchar_col, bytea_col, bit_col, varbit_col,
          date_col, time_col, timestamp_col, timestamptz_col, interval_col, timetz_col,
          int4_range_col, int8_range_col, num_range_col, ts_range_col, tstz_range_col, date_range_col,
          inet_col, cidr_col, macaddr_col, json_col, jsonb_col, uuid_col,
          bool_array_col, int4_array_col, int8_array_col, text_array_col, float8_array_col,
          int4_range_array_col, date_range_array_col,
          created_at
        FROM all_types_test
        WHERE id = $1"
    );
    let query = query.bind(id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(GetAllTypesTestItem {
        id: row.try_get::<i32, _>("id")?,
        bool_col: row.try_get::<Option<bool>, _>("bool_col")?,
        char_col: row.try_get::<Option<String>, _>("char_col")?,
        int2_col: row.try_get::<Option<i16>, _>("int2_col")?,
        int4_col: row.try_get::<Option<i32>, _>("int4_col")?,
        int8_col: row.try_get::<Option<i64>, _>("int8_col")?,
        float4_col: row.try_get::<Option<f32>, _>("float4_col")?,
        float8_col: row.try_get::<Option<f64>, _>("float8_col")?,
        numeric_col: row.try_get::<Option<rust_decimal::Decimal>, _>("numeric_col")?,
        name_col: row.try_get::<Option<String>, _>("name_col")?,
        text_col: row.try_get::<Option<String>, _>("text_col")?,
        varchar_col: row.try_get::<Option<String>, _>("varchar_col")?,
        bpchar_col: row.try_get::<Option<String>, _>("bpchar_col")?,
        bytea_col: row.try_get::<Option<Vec<u8>>, _>("bytea_col")?,
        bit_col: row.try_get::<Option<bit_vec::BitVec>, _>("bit_col")?,
        varbit_col: row.try_get::<Option<bit_vec::BitVec>, _>("varbit_col")?,
        date_col: row.try_get::<Option<chrono::NaiveDate>, _>("date_col")?,
        time_col: row.try_get::<Option<chrono::NaiveTime>, _>("time_col")?,
        timestamp_col: row.try_get::<Option<chrono::NaiveDateTime>, _>("timestamp_col")?,
        timestamptz_col: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("timestamptz_col")?,
        interval_col: row.try_get::<Option<sqlx::postgres::types::PgInterval>, _>("interval_col")?,
        timetz_col: row.try_get::<Option<sqlx::postgres::types::PgTimeTz>, _>("timetz_col")?,
        int4_range_col: row.try_get::<Option<sqlx::postgres::types::PgRange<i32>>, _>("int4_range_col")?,
        int8_range_col: row.try_get::<Option<sqlx::postgres::types::PgRange<i64>>, _>("int8_range_col")?,
        num_range_col: row.try_get::<Option<sqlx::postgres::types::PgRange<rust_decimal::Decimal>>, _>("num_range_col")?,
        ts_range_col: row.try_get::<Option<sqlx::postgres::types::PgRange<chrono::NaiveDateTime>>, _>("ts_range_col")?,
        tstz_range_col: row.try_get::<Option<sqlx::postgres::types::PgRange<chrono::DateTime<chrono::Utc>>>, _>("tstz_range_col")?,
        date_range_col: row.try_get::<Option<sqlx::postgres::types::PgRange<chrono::NaiveDate>>, _>("date_range_col")?,
        inet_col: row.try_get::<Option<std::net::IpAddr>, _>("inet_col")?,
        cidr_col: row.try_get::<Option<std::net::IpAddr>, _>("cidr_col")?,
        macaddr_col: row.try_get::<Option<mac_address::MacAddress>, _>("macaddr_col")?,
        json_col: row.try_get::<Option<serde_json::Value>, _>("json_col")?,
        jsonb_col: row.try_get::<Option<serde_json::Value>, _>("jsonb_col")?,
        uuid_col: row.try_get::<Option<uuid::Uuid>, _>("uuid_col")?,
        bool_array_col: row.try_get::<Option<Vec<bool>>, _>("bool_array_col")?,
        int4_array_col: row.try_get::<Option<Vec<i32>>, _>("int4_array_col")?,
        int8_array_col: row.try_get::<Option<Vec<i64>>, _>("int8_array_col")?,
        text_array_col: row.try_get::<Option<Vec<String>>, _>("text_array_col")?,
        float8_array_col: row.try_get::<Option<Vec<f64>>, _>("float8_array_col")?,
        int4_range_array_col: row.try_get::<Option<Vec<sqlx::postgres::types::PgRange<i32>>>, _>("int4_range_array_col")?,
        date_range_array_col: row.try_get::<Option<Vec<sqlx::postgres::types::PgRange<chrono::NaiveDate>>>, _>("date_range_array_col")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    })();
    result
}

