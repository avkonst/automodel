// AUTOMODEL_HASH: 10166514101583273512
// This file was automatically generated by AutoModel. Do not edit manually.

use sqlx::Row;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum UserStatus {
    Active,
    Inactive,
    Suspended,
    Pending,
}

impl std::str::FromStr for UserStatus {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "active" => Ok(UserStatus::Active),
            "inactive" => Ok(UserStatus::Inactive),
            "suspended" => Ok(UserStatus::Suspended),
            "pending" => Ok(UserStatus::Pending),
            _ => Err(format!("Invalid UserStatus variant: {}", s)),
        }
    }
}

impl std::fmt::Display for UserStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            UserStatus::Active => "active",
            UserStatus::Inactive => "inactive",
            UserStatus::Suspended => "suspended",
            UserStatus::Pending => "pending",
        };
        write!(f, "{}", s)
    }
}

impl sqlx::Type<sqlx::Postgres> for UserStatus {
    fn type_info() -> sqlx::postgres::PgTypeInfo {
        sqlx::postgres::PgTypeInfo::with_name("user_status")
    }
}

impl<'r> sqlx::Decode<'r, sqlx::Postgres> for UserStatus {
    fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync + 'static>> {
        let s = <&str as sqlx::Decode<sqlx::Postgres>>::decode(value)?;
        s.parse().map_err(|e| Box::new(std::io::Error::new(std::io::ErrorKind::InvalidData, e)) as Box<dyn std::error::Error + Send + Sync + 'static>)
    }
}

impl<'q> sqlx::Encode<'q, sqlx::Postgres> for UserStatus {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync + 'static>> {
        <&str as sqlx::Encode<sqlx::Postgres>>::encode(&self.to_string(), buf)
    }
}


#[derive(Debug, Clone)]
pub struct InsertUserItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Insert a new user with all fields and return the created user
#[tracing::instrument(level = "trace", skip(executor, profile), fields(sql = "INSERT INTO users (name, email, age, profile)\nVALUES (${name}, ${email}, ${age}, ${profile})\nRETURNING id, name, email, age, created_at\n"))]
pub async fn insert_user(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name: String, email: String, age: i32, profile: crate::models::UserProfile) -> Result<InsertUserItem, sqlx::Error> {
    let query = sqlx::query(
        r"INSERT INTO users (name, email, age, profile)
        VALUES ($1, $2, $3, $4)
        RETURNING id, name, email, age, created_at"
    );
    let query = query.bind(&name);
    let query = query.bind(&email);
    let query = query.bind(age);
    let query = query.bind(serde_json::to_value(&profile).map_err(|e| sqlx::Error::Encode(Box::new(e)))?);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(InsertUserItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    })();
    result
}

#[derive(Debug, Clone)]
pub struct GetAllUsersItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get all users with all their fields
#[tracing::instrument(level = "debug", skip(executor), fields(sql = "SELECT id, name, email, age, profile, created_at, updated_at FROM users ORDER BY created_at DESC"))]
pub async fn get_all_users(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<GetAllUsersItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at, updated_at FROM users ORDER BY created_at DESC"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetAllUsersItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct FindUserByEmailItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<serde_json::Value>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Find a user by their email address
#[tracing::instrument(level = "debug", skip(executor))]
pub async fn find_user_by_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, email: String) -> Result<Option<FindUserByEmailItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at, updated_at FROM users WHERE email = $1"
    );
    let query = query.bind(&email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(FindUserByEmailItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
            })();
            result.map(Some)
        },
        None => Ok(None),
    }
}

#[derive(Debug, Clone)]
pub struct UpdateUserProfileItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Update a user's profile by their ID
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE users SET profile = ${profile}, updated_at = NOW() WHERE id = ${user_id} RETURNING id, name, email, age, profile, updated_at"))]
pub async fn update_user_profile(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, profile: crate::models::UserProfile, user_id: i32) -> Result<UpdateUserProfileItem, sqlx::Error> {
    let query = sqlx::query(
        r"UPDATE users SET profile = $1, updated_at = NOW() WHERE id = $2 RETURNING id, name, email, age, profile, updated_at"
    );
    let query = query.bind(serde_json::to_value(&profile).map_err(|e| sqlx::Error::Encode(Box::new(e)))?);
    let query = query.bind(user_id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserProfileItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    })();
    result
}

#[derive(Debug, Clone)]
pub struct FindUsersByNameAndAgeItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
}

/// Find users by name pattern with optional minimum age filter (using conditional syntax)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age FROM users WHERE name ILIKE ${name_pattern} $[AND age >= ${min_age?}] AND name = ${name_exact} $[AND age <= ${max_age?}] ORDER BY name"))]
pub async fn find_users_by_name_and_age(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name_pattern: String, min_age: Option<i32>, name_exact: String, max_age: Option<i32>) -> Result<Vec<FindUsersByNameAndAgeItem>, sqlx::Error> {
    let mut final_sql = r"SELECT id, name, email, age FROM users WHERE name ILIKE $1 $[AND age >= ${min_age?}] AND name = $2 $[AND age <= ${max_age?}] ORDER BY name".to_string();
    let mut included_params = Vec::new();

    if min_age.is_some() {
        final_sql = final_sql.replace(r"$[AND age >= ${min_age?}]", r"AND age >= ${min_age?}");
        included_params.push("min_age");
    } else {
        final_sql = final_sql.replace(r"$[AND age >= ${min_age?}]", "");
    }

    if max_age.is_some() {
        final_sql = final_sql.replace(r"$[AND age <= ${max_age?}]", r"AND age <= ${max_age?}");
        included_params.push("max_age");
    } else {
        final_sql = final_sql.replace(r"$[AND age <= ${max_age?}]", "");
    }

    let mut param_counter = 1;
    final_sql = final_sql.replace(r"${name_pattern}", &format!("${}", param_counter));
    param_counter += 1;
    final_sql = final_sql.replace(r"${name_exact}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"min_age") {
        final_sql = final_sql.replace(r"${min_age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"max_age") {
        final_sql = final_sql.replace(r"${max_age?}", &format!("${}", param_counter));
        param_counter += 1;
    }

    let mut query = sqlx::query(&final_sql);

    query = query.bind(&name_pattern);
    query = query.bind(&name_exact);
    if included_params.contains(&r"min_age") {
        query = query.bind(min_age.as_ref().unwrap());
    }

    if included_params.contains(&r"max_age") {
        query = query.bind(max_age.as_ref().unwrap());
    }

    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(FindUsersByNameAndAgeItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct GetRecentUsersItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get users created after a specific timestamp - expects at least one user
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, profile, created_at, updated_at FROM users WHERE created_at > ${since} ORDER BY created_at DESC"))]
pub async fn get_recent_users(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, since: chrono::DateTime<chrono::Utc>) -> Result<Vec<GetRecentUsersItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at, updated_at FROM users WHERE created_at > $1 ORDER BY created_at DESC"
    );
    let query = query.bind(since);
    let rows = query.fetch_all(executor).await?;
    if rows.is_empty() {
        return Err(sqlx::Error::RowNotFound);
    }
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetRecentUsersItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct GetActiveUsersByAgeRangeItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get active users within an age range - must return at least one user or fails
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, profile, created_at FROM users WHERE age BETWEEN ${min_age} AND ${max_age} AND updated_at > NOW() - INTERVAL '30 days'"))]
pub async fn get_active_users_by_age_range(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, min_age: i32, max_age: i32) -> Result<Vec<GetActiveUsersByAgeRangeItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at FROM users WHERE age BETWEEN $1 AND $2 AND updated_at > NOW() - INTERVAL '30 days'"
    );
    let query = query.bind(min_age);
    let query = query.bind(max_age);
    let rows = query.fetch_all(executor).await?;
    if rows.is_empty() {
        return Err(sqlx::Error::RowNotFound);
    }
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetActiveUsersByAgeRangeItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct SearchUsersByNamePatternItem {
    pub id: i32,
    pub name: String,
    pub email: String,
}

/// Search users by name pattern - expects at least one match
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email FROM users WHERE name ILIKE ${pattern} ORDER BY name"))]
pub async fn search_users_by_name_pattern(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, pattern: String) -> Result<Vec<SearchUsersByNamePatternItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT id, name, email FROM users WHERE name ILIKE $1 ORDER BY name"
    );
    let query = query.bind(&pattern);
    let rows = query.fetch_all(executor).await?;
    if rows.is_empty() {
        return Err(sqlx::Error::RowNotFound);
    }
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(SearchUsersByNamePatternItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct SearchUsersAdvancedItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Advanced user search with multiple optional filters using conditional syntax
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, created_at FROM users WHERE 1=1 $[AND name ILIKE ${name_pattern?}] $[AND age >= ${min_age?}] $[AND created_at >= ${since?}] ORDER BY created_at DESC"))]
pub async fn search_users_advanced(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name_pattern: Option<String>, min_age: Option<i32>, since: Option<chrono::DateTime<chrono::Utc>>) -> Result<Vec<SearchUsersAdvancedItem>, sqlx::Error> {
    let mut final_sql = r"SELECT id, name, email, age, created_at FROM users WHERE 1=1 $[AND name ILIKE ${name_pattern?}] $[AND age >= ${min_age?}] $[AND created_at >= ${since?}] ORDER BY created_at DESC".to_string();
    let mut included_params = Vec::new();

    if name_pattern.is_some() {
        final_sql = final_sql.replace(r"$[AND name ILIKE ${name_pattern?}]", r"AND name ILIKE ${name_pattern?}");
        included_params.push("name_pattern");
    } else {
        final_sql = final_sql.replace(r"$[AND name ILIKE ${name_pattern?}]", "");
    }

    if min_age.is_some() {
        final_sql = final_sql.replace(r"$[AND age >= ${min_age?}]", r"AND age >= ${min_age?}");
        included_params.push("min_age");
    } else {
        final_sql = final_sql.replace(r"$[AND age >= ${min_age?}]", "");
    }

    if since.is_some() {
        final_sql = final_sql.replace(r"$[AND created_at >= ${since?}]", r"AND created_at >= ${since?}");
        included_params.push("since");
    } else {
        final_sql = final_sql.replace(r"$[AND created_at >= ${since?}]", "");
    }

    let mut param_counter = 1;
    if included_params.contains(&r"name_pattern") {
        final_sql = final_sql.replace(r"${name_pattern?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"min_age") {
        final_sql = final_sql.replace(r"${min_age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"since") {
        final_sql = final_sql.replace(r"${since?}", &format!("${}", param_counter));
        param_counter += 1;
    }

    let mut query = sqlx::query(&final_sql);

    if included_params.contains(&r"name_pattern") {
        query = query.bind(name_pattern.as_ref().unwrap());
    }

    if included_params.contains(&r"min_age") {
        query = query.bind(min_age.as_ref().unwrap());
    }

    if included_params.contains(&r"since") {
        query = query.bind(since.as_ref().unwrap());
    }

    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(SearchUsersAdvancedItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct GetUsersByStatusItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub status: Option<UserStatus>,
}

/// Get users by their status (enum parameter and enum output)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, status FROM users WHERE status = ${user_status} ORDER BY name"))]
pub async fn get_users_by_status(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_status: UserStatus) -> Result<Vec<GetUsersByStatusItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT id, name, email, status FROM users WHERE status = $1 ORDER BY name"
    );
    let query = query.bind(user_status);
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetUsersByStatusItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct UpdateUserStatusItem {
    pub id: i32,
    pub status: Option<UserStatus>,
}

/// Update user status and return the new status
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE users SET status = ${new_status} WHERE id = ${user_id} RETURNING id, status"))]
pub async fn update_user_status(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, new_status: UserStatus, user_id: i32) -> Result<UpdateUserStatusItem, sqlx::Error> {
    let query = sqlx::query(
        r"UPDATE users SET status = $1 WHERE id = $2 RETURNING id, status"
    );
    let query = query.bind(new_status);
    let query = query.bind(user_id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserStatusItem {
        id: row.try_get::<i32, _>("id")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
    })
    })();
    result
}

/// Get all possible user statuses currently in use
#[tracing::instrument(level = "debug", skip(executor), fields(sql = "SELECT DISTINCT status FROM users ORDER BY status"))]
pub async fn get_all_user_statuses(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<Option<UserStatus>>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT DISTINCT status FROM users ORDER BY status"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(row.try_get::<Option<UserStatus>, _>("status")?)
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct GetAllUsersWithStarItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<UserStatus>,
    pub referrer_id: Option<i32>,
}

/// Get all users using SELECT * to fetch all columns
#[tracing::instrument(level = "debug", skip(executor), fields(sql = "SELECT * FROM users ORDER BY created_at DESC"))]
pub async fn get_all_users_with_star(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<GetAllUsersWithStarItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT * FROM users ORDER BY created_at DESC"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetAllUsersWithStarItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
        referrer_id: row.try_get::<Option<i32>, _>("referrer_id")?,
    })
    }).collect();
    result
}

#[derive(Debug, Clone)]
pub struct GetUserByIdWithStarItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<UserStatus>,
    pub referrer_id: Option<i32>,
}

/// Get a single user by ID using SELECT * to fetch all columns
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT * FROM users WHERE id = ${user_id}"))]
pub async fn get_user_by_id_with_star(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_id: i32) -> Result<Option<GetUserByIdWithStarItem>, sqlx::Error> {
    let query = sqlx::query(
        r"SELECT * FROM users WHERE id = $1"
    );
    let query = query.bind(user_id);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(GetUserByIdWithStarItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
        referrer_id: row.try_get::<Option<i32>, _>("referrer_id")?,
    })
            })();
            result.map(Some)
        },
        None => Ok(None),
    }
}

