// This file was automatically generated by AutoModel. Do not edit manually.

use sqlx::Row;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum UserStatus {
    Active,
    Inactive,
    Suspended,
    Pending,
}

impl std::str::FromStr for UserStatus {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "active" => Ok(UserStatus::Active),
            "inactive" => Ok(UserStatus::Inactive),
            "suspended" => Ok(UserStatus::Suspended),
            "pending" => Ok(UserStatus::Pending),
            _ => Err(format!("Invalid UserStatus variant: {}", s)),
        }
    }
}

impl std::fmt::Display for UserStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            UserStatus::Active => "active",
            UserStatus::Inactive => "inactive",
            UserStatus::Suspended => "suspended",
            UserStatus::Pending => "pending",
        };
        write!(f, "{}", s)
    }
}

impl sqlx::Type<sqlx::Postgres> for UserStatus {
    fn type_info() -> sqlx::postgres::PgTypeInfo {
        sqlx::postgres::PgTypeInfo::with_name("public.user_status")
    }
}

impl<'r> sqlx::Decode<'r, sqlx::Postgres> for UserStatus {
    fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync + 'static>> {
        let s = <&str as sqlx::Decode<sqlx::Postgres>>::decode(value)?;
        s.parse().map_err(|e| Box::new(std::io::Error::new(std::io::ErrorKind::InvalidData, e)) as Box<dyn std::error::Error + Send + Sync + 'static>)
    }
}

impl<'q> sqlx::Encode<'q, sqlx::Postgres> for UserStatus {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync + 'static>> {
        <&str as sqlx::Encode<sqlx::Postgres>>::encode(&self.to_string(), buf)
    }
}


/// Constraint violations specific to this query
#[derive(Debug)]
pub enum InsertUserConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for InsertUserConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct InsertUserItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Insert a new user with all fields and return the created user
#[tracing::instrument(level = "trace", skip(executor, profile), fields(sql = "INSERT INTO public.users (name, email, age, profile)\nVALUES (#{name}, #{email}, #{age}, #{profile})\nRETURNING id, name, email, age, created_at"))]
pub async fn insert_user(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name: String, email: String, age: i32, profile: crate::models::UserProfile) -> Result<InsertUserItem, super::Error<InsertUserConstraints>> {
    let query = sqlx::query(
        r"INSERT INTO public.users (name, email, age, profile)
        VALUES ($1, $2, $3, $4)
        RETURNING id, name, email, age, created_at"
    );
    let query = query.bind(&name);
    let query = query.bind(&email);
    let query = query.bind(age);
    let query = query.bind(serde_json::to_value(&profile).map_err(|e| sqlx::Error::Encode(Box::new(e)))?);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(InsertUserItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum InsertUsersBatchConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for InsertUsersBatchConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct InsertUsersBatchRecord {
    pub name: String,
    pub email: String,
    pub age: i32,
}

/// Insert multiple public.users using UNNEST pattern with multiunzip
#[tracing::instrument(level = "debug", skip_all, fields(sql = "INSERT INTO public.users (name, email, age)\nSELECT *\nFROM UNNEST(\n        #{name}::text [],\n        #{email}::text [],\n        #{age}::int4 []\n    )"))]
pub async fn insert_users_batch(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, items: Vec<InsertUsersBatchRecord>) -> Result<(), super::Error<InsertUsersBatchConstraints>> {
    use itertools::Itertools;
    let query = sqlx::query(
        r"INSERT INTO public.users (name, email, age)
        SELECT *
        FROM UNNEST(
            $1::text [],
            $2::text [],
            $3::int4 []
          )"
    );
    let (name, email, age): (Vec<_>, Vec<_>, Vec<_>) =
        items
            .into_iter()
            .map(|item| (item.name, item.email, item.age))
            .multiunzip();
    let query = query.bind(name);
    let query = query.bind(email);
    let query = query.bind(age);
    query.execute(executor).await?;
    Ok(())
}

#[derive(Debug, Clone)]
pub struct GetAllUsersItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get all public.users with all their fields
///
/// Query Plan:
/// Sort
///   Sort Key: created_at DESC
///   ->  Seq Scan on users
/// JIT:
///   Functions: 2
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, profile, created_at, updated_at \nFROM public.users \nORDER BY created_at DESC"))]
pub async fn get_all_users(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<GetAllUsersItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at, updated_at 
        FROM public.users 
        ORDER BY created_at DESC"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetAllUsersItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct FindUserByEmailItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<serde_json::Value>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Find a user by their email address
#[tracing::instrument(level = "debug", skip_all)]
pub async fn find_user_by_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, email: String) -> Result<Option<FindUserByEmailItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at, updated_at 
        FROM public.users 
        WHERE email = $1"
    );
    let query = query.bind(&email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(FindUserByEmailItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserProfileConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserProfileConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct UpdateUserProfileItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Update a user's profile by their ID
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users\nSET profile = #{profile}, updated_at = NOW() \nWHERE id = #{user_id} \nRETURNING id,\n    name,\n    email,\n    age,\n    profile,\n    updated_at"))]
pub async fn update_user_profile(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, profile: crate::models::UserProfile, user_id: i32) -> Result<UpdateUserProfileItem, super::Error<UpdateUserProfileConstraints>> {
    let query = sqlx::query(
        r"UPDATE public.users
        SET profile = $1, updated_at = NOW() 
        WHERE id = $2 
        RETURNING id,
          name,
          email,
          age,
          profile,
          updated_at"
    );
    let query = query.bind(serde_json::to_value(&profile).map_err(|e| sqlx::Error::Encode(Box::new(e)))?);
    let query = query.bind(user_id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserProfileItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    })();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct FindUsersByNameAndAgeItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
}

/// Find public.users by name pattern with optional minimum age filter (using conditional syntax)
///
/// Query Plan:
/// === find_users_by_name_and_age (base) ===
/// Seq Scan on users
///   Filter: (((name)::text ~~* 'dummy'::text) AND ((name)::text = 'dummy'::text))
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
/// 
/// === find_users_by_name_and_age (variant 1) ===
/// Bitmap Heap Scan on users
///   Recheck Cond: (age >= 0)
///   Filter: (((name)::text ~~* 'dummy'::text) AND ((name)::text = 'dummy'::text))
///   ->  Bitmap Index Scan on idx_users_age_updated_at
///         Index Cond: (age >= 0)
/// 
/// === find_users_by_name_and_age (variant 2) ===
/// Index Scan using idx_users_age on users
///   Index Cond: (age <= 0)
///   Filter: (((name)::text ~~* 'dummy'::text) AND ((name)::text = 'dummy'::text))
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age \nFROM public.users \nWHERE name ILIKE #{name_pattern} \n#[AND age >= #{min_age?}] \nAND name = #{name_exact} \n#[AND age <= #{max_age?}] \nORDER BY name"))]
pub async fn find_users_by_name_and_age(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name_pattern: String, min_age: Option<i32>, name_exact: String, max_age: Option<i32>) -> Result<Vec<FindUsersByNameAndAgeItem>, super::ErrorReadOnly> {
    let mut final_sql = r"SELECT id, name, email, age 
FROM public.users 
WHERE name ILIKE $1 
#[AND age >= #{min_age?}] 
AND name = $2 
#[AND age <= #{max_age?}] 
ORDER BY name".to_string();
    let mut included_params = Vec::new();

    if min_age.is_some() {
        final_sql = final_sql.replace(r"#[AND age >= #{min_age?}]", r"AND age >= #{min_age?}");
        included_params.push("min_age");
    } else {
        final_sql = final_sql.replace(r"#[AND age >= #{min_age?}]", "");
    }

    if max_age.is_some() {
        final_sql = final_sql.replace(r"#[AND age <= #{max_age?}]", r"AND age <= #{max_age?}");
        included_params.push("max_age");
    } else {
        final_sql = final_sql.replace(r"#[AND age <= #{max_age?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"#{name_pattern}", &format!("${}", param_counter));
    param_counter += 1;
    final_sql = final_sql.replace(r"#{name_exact}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"min_age") {
        final_sql = final_sql.replace(r"#{min_age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"max_age") {
        final_sql = final_sql.replace(r"#{max_age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    query = query.bind(&name_pattern);
    query = query.bind(&name_exact);
    if included_params.contains(&r"min_age") {
        query = query.bind(min_age.as_ref().unwrap());
    }

    if included_params.contains(&r"max_age") {
        query = query.bind(max_age.as_ref().unwrap());
    }

    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(FindUsersByNameAndAgeItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct GetRecentUsersItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get public.users created after a specific timestamp - expects at least one user
///
/// Query Plan:
/// Sort
///   Sort Key: created_at DESC
///   ->  Seq Scan on users
///         Filter: (created_at > '1970-01-01 00:00:00+00'::timestamp with time zone)
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, profile, created_at, updated_at \nFROM public.users \nWHERE created_at > #{since} \nORDER BY created_at DESC"))]
pub async fn get_recent_users(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, since: chrono::DateTime<chrono::Utc>) -> Result<Vec<GetRecentUsersItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at, updated_at 
        FROM public.users 
        WHERE created_at > $1 
        ORDER BY created_at DESC"
    );
    let query = query.bind(since);
    let rows = query.fetch_all(executor).await?;
    if rows.is_empty() {
        return Err(sqlx::Error::RowNotFound.into());
    }
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetRecentUsersItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct GetActiveUsersByAgeRangeItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub profile: Option<crate::models::UserProfile>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get active public.users within an age range - must return at least one user or fails
///
/// Query Plan:
/// Index Scan using idx_users_age on users
///   Index Cond: ((age >= 0) AND (age <= 0))
///   Filter: (updated_at > (now - '30 days'::interval))
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, profile, created_at \nFROM public.users \nWHERE age BETWEEN #{min_age} AND #{max_age} \nAND updated_at > NOW() - INTERVAL '30 days'"))]
pub async fn get_active_users_by_age_range(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, min_age: i32, max_age: i32) -> Result<Vec<GetActiveUsersByAgeRangeItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, profile, created_at 
        FROM public.users 
        WHERE age BETWEEN $1 AND $2 
        AND updated_at > NOW() - INTERVAL '30 days'"
    );
    let query = query.bind(min_age);
    let query = query.bind(max_age);
    let rows = query.fetch_all(executor).await?;
    if rows.is_empty() {
        return Err(sqlx::Error::RowNotFound.into());
    }
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetActiveUsersByAgeRangeItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct SearchUsersByNamePatternItem {
    pub id: i32,
    pub name: String,
    pub email: String,
}

/// Search public.users by name pattern - expects at least one match
///
/// Query Plan:
/// Sort
///   Sort Key: name
///   ->  Seq Scan on users
///         Filter: ((name)::text ~~* 'dummy'::text)
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email \nFROM public.users \nWHERE name ILIKE #{pattern} \nORDER BY name"))]
pub async fn search_users_by_name_pattern(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, pattern: String) -> Result<Vec<SearchUsersByNamePatternItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email 
        FROM public.users 
        WHERE name ILIKE $1 
        ORDER BY name"
    );
    let query = query.bind(&pattern);
    let rows = query.fetch_all(executor).await?;
    if rows.is_empty() {
        return Err(sqlx::Error::RowNotFound.into());
    }
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(SearchUsersByNamePatternItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct SearchUsersAdvancedItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Advanced user search with multiple optional filters using conditional syntax
///
/// Query Plan:
/// === search_users_advanced (base) ===
/// Sort
///   Sort Key: created_at DESC
///   ->  Seq Scan on users
/// JIT:
///   Functions: 2
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
/// 
/// === search_users_advanced (variant 1) ===
/// Sort
///   Sort Key: created_at DESC
///   ->  Seq Scan on users
///         Filter: ((name)::text ~~* 'dummy'::text)
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
/// 
/// === search_users_advanced (variant 2) ===
/// Sort
///   Sort Key: created_at DESC
///   ->  Bitmap Heap Scan on users
///         Recheck Cond: (age >= 0)
///         ->  Bitmap Index Scan on idx_users_age_updated_at
///               Index Cond: (age >= 0)
/// 
/// === search_users_advanced (variant 3) ===
/// Sort
///   Sort Key: created_at DESC
///   ->  Seq Scan on users
///         Filter: (created_at >= '1970-01-01 00:00:00+00'::timestamp with time zone)
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, created_at \nFROM public.users \nWHERE 1=1 \n#[AND name ILIKE #{name_pattern?}] \n#[AND age >= #{min_age?}] \n#[AND created_at >= #{since?}] \nORDER BY created_at DESC"))]
pub async fn search_users_advanced(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name_pattern: Option<String>, min_age: Option<i32>, since: Option<chrono::DateTime<chrono::Utc>>) -> Result<Vec<SearchUsersAdvancedItem>, super::ErrorReadOnly> {
    let mut final_sql = r"SELECT id, name, email, age, created_at 
FROM public.users 
WHERE 1=1 
#[AND name ILIKE #{name_pattern?}] 
#[AND age >= #{min_age?}] 
#[AND created_at >= #{since?}] 
ORDER BY created_at DESC".to_string();
    let mut included_params = Vec::new();

    if name_pattern.is_some() {
        final_sql = final_sql.replace(r"#[AND name ILIKE #{name_pattern?}]", r"AND name ILIKE #{name_pattern?}");
        included_params.push("name_pattern");
    } else {
        final_sql = final_sql.replace(r"#[AND name ILIKE #{name_pattern?}]", "");
    }

    if min_age.is_some() {
        final_sql = final_sql.replace(r"#[AND age >= #{min_age?}]", r"AND age >= #{min_age?}");
        included_params.push("min_age");
    } else {
        final_sql = final_sql.replace(r"#[AND age >= #{min_age?}]", "");
    }

    if since.is_some() {
        final_sql = final_sql.replace(r"#[AND created_at >= #{since?}]", r"AND created_at >= #{since?}");
        included_params.push("since");
    } else {
        final_sql = final_sql.replace(r"#[AND created_at >= #{since?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    if included_params.contains(&r"name_pattern") {
        final_sql = final_sql.replace(r"#{name_pattern?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"min_age") {
        final_sql = final_sql.replace(r"#{min_age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"since") {
        final_sql = final_sql.replace(r"#{since?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    if included_params.contains(&r"name_pattern") {
        query = query.bind(name_pattern.as_ref().unwrap());
    }

    if included_params.contains(&r"min_age") {
        query = query.bind(min_age.as_ref().unwrap());
    }

    if included_params.contains(&r"since") {
        query = query.bind(since.as_ref().unwrap());
    }

    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(SearchUsersAdvancedItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct GetUsersByStatusItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub status: Option<UserStatus>,
}

/// Get public.users by their status (enum parameter and enum output)
///
/// Query Plan:
/// Sort
///   Sort Key: name
///   ->  Seq Scan on users
///         Filter: (status = 'active'::public.user_status)
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, status \nFROM public.users \nWHERE status = #{user_status} \nORDER BY name"))]
pub async fn get_users_by_status(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_status: UserStatus) -> Result<Vec<GetUsersByStatusItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, status 
        FROM public.users 
        WHERE status = $1 
        ORDER BY name"
    );
    let query = query.bind(user_status);
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetUsersByStatusItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
    })
    }).collect();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserStatusConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserStatusConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct UpdateUserStatusItem {
    pub id: i32,
    pub status: Option<UserStatus>,
}

/// Update user status and return the new status
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET status = #{new_status} \nWHERE id = #{user_id} \nRETURNING id, status"))]
pub async fn update_user_status(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, new_status: UserStatus, user_id: i32) -> Result<UpdateUserStatusItem, super::Error<UpdateUserStatusConstraints>> {
    let query = sqlx::query(
        r"UPDATE public.users 
        SET status = $1 
        WHERE id = $2 
        RETURNING id, status"
    );
    let query = query.bind(new_status);
    let query = query.bind(user_id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserStatusItem {
        id: row.try_get::<i32, _>("id")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserFieldsConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserFieldsConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct UpdateUserFieldsItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Update user fields conditionally - only updates fields that are provided (not None)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET updated_at = NOW() \n#[, name = #{name?}] \n#[, email = #{email?}] \n#[, age = #{age?}] \nWHERE id = #{user_id} \nRETURNING id, name, email, age, updated_at"))]
pub async fn update_user_fields(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, name: Option<String>, email: Option<String>, age: Option<i32>, user_id: i32) -> Result<UpdateUserFieldsItem, super::Error<UpdateUserFieldsConstraints>> {
    let mut final_sql = r"UPDATE public.users 
SET updated_at = NOW() 
#[, name = #{name?}] 
#[, email = #{email?}] 
#[, age = #{age?}] 
WHERE id = $1 
RETURNING id, name, email, age, updated_at".to_string();
    let mut included_params = Vec::new();

    if name.is_some() {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", r", name = #{name?}");
        included_params.push("name");
    } else {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", "");
    }

    if email.is_some() {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", r", email = #{email?}");
        included_params.push("email");
    } else {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", "");
    }

    if age.is_some() {
        final_sql = final_sql.replace(r"#[, age = #{age?}]", r", age = #{age?}");
        included_params.push("age");
    } else {
        final_sql = final_sql.replace(r"#[, age = #{age?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"#{user_id}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"name") {
        final_sql = final_sql.replace(r"#{name?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"email") {
        final_sql = final_sql.replace(r"#{email?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"age") {
        final_sql = final_sql.replace(r"#{age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    query = query.bind(&user_id);
    if included_params.contains(&r"name") {
        query = query.bind(name.as_ref().unwrap());
    }

    if included_params.contains(&r"email") {
        query = query.bind(email.as_ref().unwrap());
    }

    if included_params.contains(&r"age") {
        query = query.bind(age.as_ref().unwrap());
    }

    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserFieldsItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserFieldsDiffConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserFieldsDiffConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct UpdateUserFieldsDiffParams {
    pub name: String,
    pub email: String,
    pub age: i32,
}

#[derive(Debug, Clone)]
pub struct UpdateUserFieldsDiffItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Update user fields using diff-based conditional updates - compares old and new structs
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET updated_at = NOW() \n#[, name = #{name?}] \n#[, email = #{email?}] \n#[, age = #{age?}] \nWHERE id = #{user_id} \nRETURNING id, name, email, age, updated_at"))]
pub async fn update_user_fields_diff(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, old: &UpdateUserFieldsDiffParams, new: &UpdateUserFieldsDiffParams, user_id: i32) -> Result<UpdateUserFieldsDiffItem, super::Error<UpdateUserFieldsDiffConstraints>> {
    let mut final_sql = r"UPDATE public.users 
SET updated_at = NOW() 
#[, name = #{name?}] 
#[, email = #{email?}] 
#[, age = #{age?}] 
WHERE id = $1 
RETURNING id, name, email, age, updated_at".to_string();
    let mut included_params = Vec::new();

    if old.name != new.name {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", r", name = #{name?}");
        included_params.push("name");
    } else {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", "");
    }

    if old.email != new.email {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", r", email = #{email?}");
        included_params.push("email");
    } else {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", "");
    }

    if old.age != new.age {
        final_sql = final_sql.replace(r"#[, age = #{age?}]", r", age = #{age?}");
        included_params.push("age");
    } else {
        final_sql = final_sql.replace(r"#[, age = #{age?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"#{user_id}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"name") {
        final_sql = final_sql.replace(r"#{name?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"email") {
        final_sql = final_sql.replace(r"#{email?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"age") {
        final_sql = final_sql.replace(r"#{age?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    query = query.bind(&user_id);
    if included_params.contains(&r"name") {
        query = query.bind(&new.name);
    }

    if included_params.contains(&r"email") {
        query = query.bind(&new.email);
    }

    if included_params.contains(&r"age") {
        query = query.bind(&new.age);
    }

    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserFieldsDiffItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum InsertUserStructuredConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for InsertUserStructuredConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct InsertUserStructuredParams {
    pub name: String,
    pub email: String,
    pub age: i32,
}

#[derive(Debug, Clone)]
pub struct InsertUserStructuredItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Insert a new user using structured parameters - all params passed as a single struct
#[tracing::instrument(level = "debug", skip_all, fields(sql = "INSERT INTO public.users (name, email, age) \nVALUES (#{name}, #{email}, #{age}) \nRETURNING id, name, email, age, created_at"))]
pub async fn insert_user_structured(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &InsertUserStructuredParams) -> Result<InsertUserStructuredItem, super::Error<InsertUserStructuredConstraints>> {
    let query = sqlx::query(
        r"INSERT INTO public.users (name, email, age) 
        VALUES ($1, $2, $3) 
        RETURNING id, name, email, age, created_at"
    );
    let query = query.bind(&params.name);
    let query = query.bind(&params.email);
    let query = query.bind(params.age);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(InsertUserStructuredItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    })();
    result.map_err(Into::into)
}

/// Get all possible user statuses currently in use
///
/// Query Plan:
/// Unique
///   ->  Sort
///         Sort Key: status
///         ->  Seq Scan on users
/// JIT:
///   Functions: 3
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT DISTINCT status \nFROM public.users \nORDER BY status"))]
pub async fn get_all_user_statuses(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<Option<UserStatus>>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT DISTINCT status 
        FROM public.users 
        ORDER BY status"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(row.try_get::<Option<UserStatus>, _>("status")?)
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct GetAllUsersWithStarItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub status: Option<UserStatus>,
    pub profile: Option<crate::models::UserProfile>,
    pub settings: Option<serde_json::Value>,
    pub is_active: Option<bool>,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub referrer_id: Option<i32>,
}

/// Get all public.users using SELECT * to fetch all columns
///
/// Query Plan:
/// Sort
///   Sort Key: created_at DESC
///   ->  Seq Scan on users
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT * \nFROM public.users \nORDER BY created_at DESC"))]
pub async fn get_all_users_with_star(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<GetAllUsersWithStarItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT * 
        FROM public.users 
        ORDER BY created_at DESC"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(GetAllUsersWithStarItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        settings: row.try_get::<Option<serde_json::Value>, _>("settings")?,
        is_active: row.try_get::<Option<bool>, _>("is_active")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
        referrer_id: row.try_get::<Option<i32>, _>("referrer_id")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct GetUserByIdWithStarItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub status: Option<UserStatus>,
    pub profile: Option<crate::models::UserProfile>,
    pub settings: Option<serde_json::Value>,
    pub is_active: Option<bool>,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub referrer_id: Option<i32>,
}

/// Get a single user by ID using SELECT * to fetch all columns
///
/// Query Plan:
/// Index Scan using users_pkey on users
///   Index Cond: (id = 0)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT * \nFROM public.users \nWHERE id = #{user_id}"))]
pub async fn get_user_by_id_with_star(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_id: i32) -> Result<Option<GetUserByIdWithStarItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT * 
        FROM public.users 
        WHERE id = $1"
    );
    let query = query.bind(user_id);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(GetUserByIdWithStarItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        status: row.try_get::<Option<UserStatus>, _>("status")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        settings: row.try_get::<Option<serde_json::Value>, _>("settings")?,
        is_active: row.try_get::<Option<bool>, _>("is_active")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
        referrer_id: row.try_get::<Option<i32>, _>("referrer_id")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

#[derive(Debug, Clone)]
pub struct GetUserByIdAndEmailParams {
    pub id: i32,
    pub email: String,
}

#[derive(Debug, Clone)]
pub struct GetUserByIdAndEmailItem {
    pub id: i32,
    pub name: String,
    pub email: String,
}

/// Get a user by ID and email - generates GetUserByIdAndEmailParams struct and GetUserByIdAndEmailItem return struct
///
/// Query Plan:
/// Index Scan using users_email_key on users
///   Index Cond: ((email)::text = 'dummy'::text)
///   Filter: (id = 0)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email \nFROM public.users \nWHERE id = #{id} AND email = #{email}"))]
pub async fn get_user_by_id_and_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &GetUserByIdAndEmailParams) -> Result<Option<GetUserByIdAndEmailItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email 
        FROM public.users 
        WHERE id = $1 AND email = $2"
    );
    let query = query.bind(params.id);
    let query = query.bind(&params.email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(GetUserByIdAndEmailItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum DeleteUserByIdAndEmailConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for DeleteUserByIdAndEmailConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct DeleteUserByIdAndEmailItem {
    pub id: i32,
    pub email: String,
}

/// Delete user by ID and email - reuses GetUserByIdAndEmailParams struct
#[tracing::instrument(level = "debug", skip_all, fields(sql = "DELETE FROM public.users \nWHERE id = #{id} AND email = #{email} \nRETURNING id, email"))]
pub async fn delete_user_by_id_and_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &GetUserByIdAndEmailParams) -> Result<DeleteUserByIdAndEmailItem, super::Error<DeleteUserByIdAndEmailConstraints>> {
    let query = sqlx::query(
        r"DELETE FROM public.users 
        WHERE id = $1 AND email = $2 
        RETURNING id, email"
    );
    let query = query.bind(params.id);
    let query = query.bind(&params.email);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(DeleteUserByIdAndEmailItem {
        id: row.try_get::<i32, _>("id")?,
        email: row.try_get::<String, _>("email")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserContactInfoConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserContactInfoConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct UpdateUserContactInfoItem {
    pub id: i32,
    pub name: String,
    pub email: String,
}

/// Update user contact info - reuses GetUserByIdAndEmailItem return struct as params
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET name = #{name}, email = #{email} \nWHERE id = #{id} \nRETURNING id, name, email"))]
pub async fn update_user_contact_info(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &GetUserByIdAndEmailItem) -> Result<UpdateUserContactInfoItem, super::Error<UpdateUserContactInfoConstraints>> {
    let query = sqlx::query(
        r"UPDATE public.users 
        SET name = $1, email = $2 
        WHERE id = $3 
        RETURNING id, name, email"
    );
    let query = query.bind(&params.name);
    let query = query.bind(&params.email);
    let query = query.bind(params.id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserContactInfoItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserProfileDiffConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserProfileDiffConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct UpdateUserProfileDiffParams {
    pub name: String,
    pub email: String,
}

#[derive(Debug, Clone)]
pub struct UpdateUserProfileDiffItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub profile: Option<crate::models::UserProfile>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Update user profile with conditional name/email - generates UpdateUserProfileDiffParams
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET profile = #{profile}, updated_at = NOW() \n#[, name = #{name?}] \n#[, email = #{email?}] \nWHERE id = #{user_id} \nRETURNING id, name, email, profile, updated_at"))]
pub async fn update_user_profile_diff(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, old: &UpdateUserProfileDiffParams, new: &UpdateUserProfileDiffParams, profile: crate::models::UserProfile, user_id: i32) -> Result<UpdateUserProfileDiffItem, super::Error<UpdateUserProfileDiffConstraints>> {
    let mut final_sql = r"UPDATE public.users 
SET profile = $1, updated_at = NOW() 
#[, name = #{name?}] 
#[, email = #{email?}] 
WHERE id = $2 
RETURNING id, name, email, profile, updated_at".to_string();
    let mut included_params = Vec::new();

    if old.name != new.name {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", r", name = #{name?}");
        included_params.push("name");
    } else {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", "");
    }

    if old.email != new.email {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", r", email = #{email?}");
        included_params.push("email");
    } else {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"#{profile}", &format!("${}", param_counter));
    param_counter += 1;
    final_sql = final_sql.replace(r"#{user_id}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"name") {
        final_sql = final_sql.replace(r"#{name?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"email") {
        final_sql = final_sql.replace(r"#{email?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    let profile_json = serde_json::to_value(&profile).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;
    query = query.bind(profile_json);
    query = query.bind(&user_id);
    if included_params.contains(&r"name") {
        query = query.bind(&new.name);
    }

    if included_params.contains(&r"email") {
        query = query.bind(&new.email);
    }

    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserProfileDiffItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        profile: row.try_get::<Option<serde_json::Value>, _>("profile")?
            .map(|v| serde_json::from_value::<crate::models::UserProfile>(v)
            .map_err(|e| sqlx::Error::Decode(Box::new(e))))
            .transpose()?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    })();
    result.map_err(Into::into)
}

/// Constraint violations specific to this query
#[derive(Debug)]
pub enum UpdateUserMetadataDiffConstraints {
    /// Constraint: users_email_key on table users
    UsersEmailKey,
    /// Constraint: users_pkey on table users
    UsersPkey,
    /// Constraint: users_referrer_id_fkey on table users
    UsersReferrerIdFkey,
    /// Constraint: users_id_not_null on table users
    UsersIdNotNull,
    /// Constraint: users_name_not_null on table users
    UsersNameNotNull,
    /// Constraint: users_email_not_null on table users
    UsersEmailNotNull,
}

impl TryFrom<super::ErrorConstraintInfo> for UpdateUserMetadataDiffConstraints {
    type Error = ();

    fn try_from(info: super::ErrorConstraintInfo) -> Result<Self, Self::Error> {
        match info.constraint_name.as_str() {
            "users_email_key" => Ok(Self::UsersEmailKey),
            "users_pkey" => Ok(Self::UsersPkey),
            "users_referrer_id_fkey" => Ok(Self::UsersReferrerIdFkey),
            "users_id_not_null" => Ok(Self::UsersIdNotNull),
            "users_name_not_null" => Ok(Self::UsersNameNotNull),
            "users_email_not_null" => Ok(Self::UsersEmailNotNull),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct UpdateUserMetadataDiffItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Update user metadata - reuses UpdateUserProfileDiffParams struct
#[tracing::instrument(level = "debug", skip_all, fields(sql = "UPDATE public.users \nSET profile = #{profile}, updated_at = NOW() \n#[, name = #{name?}] \n#[, email = #{email?}] \nWHERE id = #{user_id} \nRETURNING id, name, email, updated_at"))]
pub async fn update_user_metadata_diff(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, old: &UpdateUserProfileDiffParams, new: &UpdateUserProfileDiffParams, profile: crate::models::UserProfile, user_id: i32) -> Result<UpdateUserMetadataDiffItem, super::Error<UpdateUserMetadataDiffConstraints>> {
    let mut final_sql = r"UPDATE public.users 
SET profile = $1, updated_at = NOW() 
#[, name = #{name?}] 
#[, email = #{email?}] 
WHERE id = $2 
RETURNING id, name, email, updated_at".to_string();
    let mut included_params = Vec::new();

    if old.name != new.name {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", r", name = #{name?}");
        included_params.push("name");
    } else {
        final_sql = final_sql.replace(r"#[, name = #{name?}]", "");
    }

    if old.email != new.email {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", r", email = #{email?}");
        included_params.push("email");
    } else {
        final_sql = final_sql.replace(r"#[, email = #{email?}]", "");
    }

    #[allow(unused_assignments)]
    let mut param_counter = 1;
    final_sql = final_sql.replace(r"#{profile}", &format!("${}", param_counter));
    param_counter += 1;
    final_sql = final_sql.replace(r"#{user_id}", &format!("${}", param_counter));
    param_counter += 1;
    if included_params.contains(&r"name") {
        final_sql = final_sql.replace(r"#{name?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    if included_params.contains(&r"email") {
        final_sql = final_sql.replace(r"#{email?}", &format!("${}", param_counter));
        param_counter += 1;
    }
    let _ = param_counter; // Suppress unused assignment warning

    let mut query = sqlx::query(&final_sql);

    let profile_json = serde_json::to_value(&profile).map_err(|e| sqlx::Error::Encode(Box::new(e)))?;
    query = query.bind(profile_json);
    query = query.bind(&user_id);
    if included_params.contains(&r"name") {
        query = query.bind(&new.name);
    }

    if included_params.contains(&r"email") {
        query = query.bind(&new.email);
    }

    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UpdateUserMetadataDiffItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        updated_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("updated_at")?,
    })
    })();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct UserSummary {
    pub id: i32,
    pub name: String,
    pub email: String,
}

/// Get user summary - generates UserSummary return struct with custom name
///
/// Query Plan:
/// Index Scan using users_pkey on users
///   Index Cond: (id = 0)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email \nFROM public.users \nWHERE id = #{user_id}"))]
pub async fn get_user_summary(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_id: i32) -> Result<UserSummary, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email 
        FROM public.users 
        WHERE id = $1"
    );
    let query = query.bind(user_id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserSummary {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
    })();
    result.map_err(Into::into)
}

/// Get user info by email - reuses UserSummary return struct
///
/// Query Plan:
/// Index Scan using users_email_key on users
///   Index Cond: ((email)::text = 'dummy'::text)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email \nFROM public.users \nWHERE email = #{email}"))]
pub async fn get_user_info_by_email(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, email: String) -> Result<Option<UserSummary>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email 
        FROM public.users 
        WHERE email = $1"
    );
    let query = query.bind(&email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(UserSummary {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

/// Get all user summaries - reuses UserSummary return struct
///
/// Query Plan:
/// Sort
///   Sort Key: name
///   ->  Seq Scan on users
/// JIT:
///   Functions: 2
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email \nFROM public.users \nORDER BY name"))]
pub async fn get_all_user_summaries(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>) -> Result<Vec<UserSummary>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email 
        FROM public.users 
        ORDER BY name"
    );
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(UserSummary {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
    }).collect();
    result.map_err(Into::into)
}

#[derive(Debug, Clone)]
pub struct UserDetails {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Get user details with age and created_at - generates UserDetails return struct
///
/// Query Plan:
/// Index Scan using users_pkey on users
///   Index Cond: (id = 0)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, created_at \nFROM public.users \nWHERE id = #{user_id}"))]
pub async fn get_user_details(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_id: i32) -> Result<UserDetails, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, created_at 
        FROM public.users 
        WHERE id = $1"
    );
    let query = query.bind(user_id);
    let row = query.fetch_one(executor).await?;
    let result: Result<_, sqlx::Error> = (|| {
        Ok(UserDetails {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    })();
    result.map_err(Into::into)
}

/// Search user details - reuses UserDetails return struct
///
/// Query Plan:
/// Seq Scan on users
///   Filter: ((name)::text ~~* 'dummy'::text)
/// JIT:
///   Functions: 4
///   Options: Inlining true, Optimization true, Expressions true, Deforming true
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, age, created_at \nFROM public.users \nWHERE name ILIKE #{pattern}"))]
pub async fn search_user_details(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, pattern: String) -> Result<Vec<UserDetails>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, age, created_at 
        FROM public.users 
        WHERE name ILIKE $1"
    );
    let query = query.bind(&pattern);
    let rows = query.fetch_all(executor).await?;
    let result: Result<Vec<_>, sqlx::Error> = rows.iter().map(|row| {
        Ok(UserDetails {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        age: row.try_get::<Option<i32>, _>("age")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
    }).collect();
    result.map_err(Into::into)
}

/// Find user by criteria - uses GetUserByIdAndEmailParams for params and UserSummary for return
///
/// Query Plan:
/// Index Scan using users_email_key on users
///   Index Cond: ((email)::text = 'dummy'::text)
///   Filter: (id = 0)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email \nFROM public.users \nWHERE id = #{id} AND email = #{email}"))]
pub async fn find_user_by_criteria(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, params: &GetUserByIdAndEmailParams) -> Result<Option<UserSummary>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email 
        FROM public.users 
        WHERE id = $1 AND email = $2"
    );
    let query = query.bind(params.id);
    let query = query.bind(&params.email);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(UserSummary {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

#[derive(Debug, Clone)]
pub struct GetUserSimpleItem {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Simple user lookup by ID with detailed info
///
/// Query Plan:
/// Index Scan using users_pkey on users
///   Index Cond: (id = 0)
#[tracing::instrument(level = "debug", skip_all, fields(sql = "SELECT id, name, email, created_at\nFROM public.users\nWHERE id = #{user_id}"))]
pub async fn get_user_simple(executor: impl sqlx::Executor<'_, Database = sqlx::Postgres>, user_id: i32) -> Result<Option<GetUserSimpleItem>, super::ErrorReadOnly> {
    let query = sqlx::query(
        r"SELECT id, name, email, created_at
        FROM public.users
        WHERE id = $1"
    );
    let query = query.bind(user_id);
    let row = query.fetch_optional(executor).await?;
    match row {
        Some(row) => {
            let result: Result<_, sqlx::Error> = (|| {
                Ok(GetUserSimpleItem {
        id: row.try_get::<i32, _>("id")?,
        name: row.try_get::<String, _>("name")?,
        email: row.try_get::<String, _>("email")?,
        created_at: row.try_get::<Option<chrono::DateTime<chrono::Utc>>, _>("created_at")?,
    })
            })();
            result.map(Some).map_err(Into::into)
        },
        None => Ok(None),
    }
}

